import io
import sys

var linenum := 1

var unicode
method setunicode(u) {
    unicode := u
}
var util
method setutil(u) {
    util := u
}
method hexdecchar(c) {
    var chars := ["0", "1", "2", "3", "4", "5", "6", "7", "8",
                 "9", "a", "b", "c", "d", "e", "f"]
    var ret := 0
    for (0..15) do {i->
        if (chars.at(i) == c) then {
            ret := i
        }
    }
    ret
}

class IdentifierToken { s ->
    var kind := "identifier"
    var value := s
}
class StringToken { s ->
    var kind := "string"
    var value := s
}
class OctetsToken { s ->
    var kind := "octets"
    var value := s
}
class LBraceToken {
    var kind := "lbrace"
    var value := "{"
}
var LBraceTokenV := LBraceToken.new
class RBraceToken {
    var kind := "rbrace"
    var value := "}"
}
var RBraceTokenV := RBraceToken.new
class LParenToken {
    var kind := "lparen"
    var value := "("
}
var LParenTokenV := LParenToken.new
class RParenToken {
    var kind := "rparen"
    var value := ")"
}
var RParenTokenV := RParenToken.new
class LSquareToken {
    var kind := "lsquare"
    var value := "["
}
var LSquareTokenV := LSquareToken.new
class RSquareToken {
    var kind := "rsquare"
    var value := "]"
}
var RSquareTokenV := RSquareToken.new
class CommaToken {
    var kind := "comma"
    var value := ","
}
var CommaTokenV := CommaToken.new
class ColonToken {
    var kind := "colon"
    var value := ":"
}
var ColonTokenV := ColonToken.new
class DotToken {
    var kind := "dot"
    var value := "."
}
var DotTokenV := DotToken.new
class NumToken { v ->
    var kind := "num"
    var value := v
}
class KeywordToken { v ->
    var kind := "keyword"
    var value := v
}
class OpToken { v ->
    var kind := "op"
    var value := v
}
class ArrowToken {
    var kind := "arrow"
    var value := "->"
}
var ArrowTokenV := ArrowToken.new
class BindToken {
    var kind := "bind"
    var value := ":="
}
var BindTokenV := BindToken.new


method modechange(tokens, mode, accum) {
    var done := false
    var tok := 0
    if ((mode /= "n") | (accum.size > 0)) then {
        if (mode == "i") then {
            tok := IdentifierToken.new(accum)
            if ((accum == "object") | (accum == "method")
                | (accum == "var") | (accum == "const")
                | (accum == "import") | (accum == "class")
                | (accum == "return")) then {
                tok := KeywordToken.new(accum)
            }
            tokens.push(tok)
            done := true
        }
        if (mode == "\"") then {
            tok := StringToken.new(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == "x") then {
            tok := OctetsToken.new(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == ",") then {
            tok := CommaTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == ".") then {
            tok := DotTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "{") then {
            tok := LBraceTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "}") then {
            tok := RBraceTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "(") then {
            tok := LParenTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == ")") then {
            tok := RParenTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "[") then {
            tok := LSquareTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "]") then {
            tok := RSquareTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "m") then {
            tok := NumToken.new(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == "o") then {
            tok := OpToken.new(accum)
            if (accum == "->") then {
                tok := ArrowTokenV
            }
            if (accum == ":=") then {
                tok := BindTokenV
            }
            if (accum == ":") then {
                tok := ColonTokenV
            }
            tokens.push(tok)
            done := true
        }
        if (mode == "n") then {
            done := true
        }
        if (mode == "c") then {
            done := true
        }
        if (done) then {
            //print(mode, accum, tokens)
        } else {
            util.syntax_error("Lexing error: no handler for mode " ++ mode ++
                " with accum " ++ accum)
        }
    }
}

method lexinput() {
    util.log_verbose("reading source.")
    var input := util.infile.read()

    method isidentifierchar(ov) {
        if (unicode.isLetter(ov) | unicode.isNumber(ov)
            | (ov == 95) | (ov == 39)) then {
            // 95 is _, 39 is '
            true
        } else {
            false
        }
    }
    method isoperatorchar(c, ordval) {
        var ret := false
        if ((c == "-") | (c == "&") | (c == "|") | (c == ":") | (c == "%")
            | (c == "*") | (c == "/")) then {
            ret := true
        } elseif (unicode.isSymbolMathematical(ordval)) then {
            ret := true
        }
        ret
    }

    var tokens := []
    var mode := "n"
    var newmode := mode
    var instr := false
    var accum := ""
    var escaped := false
    var prev := ""
    var unichars := 0
    var codepoint := 0
    util.log_verbose("lexing.")
    for (input) do { c ->
        var ct := ""
        var ordval := c.ord
        if ((unicode.isSeparator(ordval) & (ordval /= 32) & (ordval /= 8232)) |
            (ordval == 9)) then {
            util.syntax_error("illegal whitespace in input: " ++ ordval ++ ", "
                ++ unicode.name(c))
        }
        if (unicode.isControl(ordval) & (ordval /= 10) & (ordval /= 13)) then {
            util.syntax_error("illegal control character in input: #" ++ ordval)
        }
        if (instr) then {

        } elseif (mode /= "c") then {
            if (c == " ") then {
                newmode := "n"
            }
            if (c == "\"") then {
                newmode := "\""
                instr := true
                if prev == "x" then {
                    newmode := "x"
                    mode := "n"
                }
            }
            ct := isidentifierchar(ordval)
            if (ct) then {
                newmode := "i"
            }
            ct := ((ordval >= 48) & (ordval <=57))
            if (ct & (mode /= "i")) then {
                newmode := "m"
            }
            if (isoperatorchar(c, ordval)) then {
                newmode := "o"
            }
            if ((c == "(") | (c == ")") | (c == ",") | (c == ".")
                | (c == "{") | (c == "}") | (c == "[") | (c == "]")) then {
                newmode := c
            }
            if ((c == ".") & (accum == ".")) then {
                mode := "o"
                newmode := mode
            }
            if ((c == "/") & (accum == "/")) then {
                mode := "c"
                newmode := mode
            }
        }
        if ((mode == "x") & (c == "\"") & (escaped.not)) then {
            newmode := "n"
            instr := false
        }
        if ((mode == "\"") & (c == "\"") & (escaped.not)) then {
            newmode := "n"
            instr := false
        }
        if (newmode /= mode) then {
            modechange(tokens, mode, accum)
            mode := newmode
            if (instr) then {
                accum := ""
            } else {
                accum := c
            }
            if ((mode == "(") | (mode == ")") | (mode == "[")
                | (mode == "]")) then {
                modechange(tokens, mode, accum)
                mode := "n"
                newmode := "n"
                accum := ""
            }
        } elseif (instr) then {
            if c == "\n" then {
                util.syntax_error("Newlines not permitted in string literals")
            }
            if (escaped) then {
                if ((c == "l") | (c == "n")) then {
                    accum := accum ++ "\n"
                } elseif (c == "u") then {
                    unichars := 4
                    codepoint := 0
                } elseif (c == "U") then {
                    unichars := 6
                    codepoint := 0
                } else {
                    accum := accum ++ c
                }
                escaped := false
            } elseif (c == "\\") then {
                escaped := true
            } elseif (unichars > 0) then {
                unichars := unichars - 1
                codepoint := codepoint * 16
                codepoint := codepoint + hexdecchar(c)
                if (unichars == 0) then {
                    accum := accum ++ unicode.create(codepoint)
                }
            } else {
                accum := accum ++ c
            }
        } elseif (c == "\n") then {
            modechange(tokens, mode, accum)
            mode := "n"
            newmode := "n"
            accum := ""
        } else {
            accum := accum ++ c
        }
        if (c == "\n") then {
            linenum := linenum + 1
            tokens.push(object {
                var kind := "line"
                var value := linenum + 0
            })
        }
        prev := c
    }
    modechange(tokens, mode, accum)
    tokens
}
