import io
import ast
import util

var lastline := 0
var linenum := 0
var lastIndent := 0
var minIndentLevel := 0
var statementIndent := 0
var tokens := 0
var values := []

// Global object containing the current token
var sym := object {
    var sym
}
var lastToken := sym.sym

// Advance to the next token in the stream, with special handling
// so the magic "line" tokens update the line number for error output.
method next() {
    lastToken := sym.sym
    if (tokens.size > 0) then {
        lastline := linenum
        lastIndent := sym.sym.indent
        sym.sym := tokens.pop()
        linenum := sym.sym.line
        util.setPosition(sym.sym.line, sym.sym.linePos)
    } else {
        sym.sym := object {
            var kind := "eof"
            var line := linenum + 1
            var linePos := 0
            var indent := 0
            var value := ""
        }
    }
}

// True if the current token (next to be processed) is a t, where
// t is "num", "string", "method", etc.
method accept(t) {
    sym.sym.kind == t
}

// True if the current token is a t, and it is on the same logical
// line (either because it's on the same physical line, or because
// it's on an indented continuation line).
method acceptSameLine(t) {
    (sym.sym.kind == t) & ((lastline == sym.sym.line) |
        (sym.sym.indent > lastIndent))
}

// True if the current token is a t, and it is on the same logical
// line as a provided token.
method accept(t)onLineOf(other) {
    (sym.sym.kind == t) & ((other.line == sym.sym.line) |
        (sym.sym.indent > other.indent))
}

// Push the current token onto the output stack as a number
method pushnum() {
    var o := ast.astnum(sym.sym.value)
    values.push(o)
    next()
}

// Push the current token onto the output stack as an octet literal
method pushoctets() {
    var o := ast.astoctets(sym.sym.value)
    values.push(o)
    next()
}

// Push the current token onto the output stack as a string
method pushstring() {
    var o := ast.aststring(sym.sym.value)
    values.push(o)
    next()
}

// Push the current token onto the output stack as an identifier.
// false means that this identifier has not been assigned a type (yet).
method pushidentifier() {
    var o := ast.astidentifier(sym.sym.value, false)
    values.push(o)
    next()
}

// Accept a block
method block() {
    if (accept("lbrace")) then {
        next()
        var minInd := statementIndent + 1
        var ident1
        var s := sym.sym
        var tmp
        var params := []
        var body := []
        var havearrow := true
        var found := false
        var i := 0
        var toks := tokens

        // TODO Clean this up, it's a hack.
        // The below scans through thirty tokens searching for either
        // an arrow or something that cannot currently appear in a
        // block's parameter list in order to determine how to treat
        // these tokens.
        for (0..30) do { i->
            if (i < (toks.size-1)) then {
                var t := toks.at((toks.size - i) - 1)
                if ((t.kind /= "identifier") & (t.kind /= "comma")
                    & (t.kind /= "arrow") & (t.kind /= "colon")
                    & found.not) then {
                    havearrow := false
                }
                if (t.kind == "arrow") then {
                    found := true
                }
            }
        }
        if (havearrow & accept("identifier")) then {
            // This block has parameters
            pushidentifier()
            ident1 := values.pop()
            if (accept("comma") | accept("arrow") | accept("colon")) then {
                if (accept("colon")) then {
                    // Take a type here, and assign it to the AST node's
                    // type field. In the long run, types will need to be
                    // handled specially, but treating them as identifiers
                    // works syntactically for now.
                    next()
                    pushidentifier()
                    ident1.type := values.pop()
                }
                params.push(ident1)
                while {accept("comma")} do {
                    // Keep doing the above for the rest of the parameters.
                    next()
                    pushidentifier()
                    ident1 := values.pop()
                    if (accept("colon")) then {
                        next()
                        pushidentifier()
                        ident1.type := values.pop()
                    }
                    params.push(ident1)
                }
                if ((accept("arrow")).not) then {
                    util.syntax_error("block parameter list not terminated ->.")
                }
                next()
            }
        }
        if (accept("arrow")) then {
            next()
        }
        var ln := values.size
        if (sym.sym.line == lastToken.line) then {
            minIndentLevel := sym.sym.linePos - 1
        } else {
            minIndentLevel := minInd
        }
        while {(accept("rbrace")).not} do {
            // Take the body of the block
            statement()
            if (ln == values.size) then {
                util.syntax_error("expected statement, have " ++ sym.sym.kind)
            }
            tmp := values.pop()
            body.push(tmp)
        }
        minIndentLevel := minInd - 1
        next()
        var o := ast.astblock(params, body)
        values.push(o)
    }
}

// Accept an "if" statement. This is a special syntactic case, rather
// than just a call with a multi-part method name - it might be possible
// to change that and compensate later on.
method doif() {
    if (accept("identifier") & (sym.sym.value == "if")) then {
        next()
        expression()
        var cond := values.pop()
        var body := []

        // These two are for else/elseif handling. elseif is turned into
        // nested if statements for the AST, so curelse points to the
        // most deeply-nested of those (where any eventual "else" block's
        // statements will go). elseblock contains the statements of the
        // top-level "else" block - if there are any elseifs, that
        // consists of only one statement, another if.
        var elseblock := []
        var curelse := elseblock
        var v
        var localMin
        var minInd := statementIndent + 1
        if (accept("identifier") & (sym.sym.value == "then")) then {
            next()
            if (accept("lbrace")) then {
                next()
                if (sym.sym.line == lastToken.line) then {
                    minIndentLevel := sym.sym.linePos - 1
                } else {
                    minIndentLevel := minInd
                }
                while {(accept("rbrace")).not} do {
                    statement()
                    v := values.pop()
                    body.push(v)
                }
                next()
            }
            var econd
            var eif
            var newelse
            var ebody
            while {accept("identifier") & (sym.sym.value == "elseif")} do {
                // Currently, the parser just accepts arbitrarily many
                // "elseifs", turning them into ifs inside the else.
                next()
                expression()
                econd := values.pop()
                if ((accept("identifier") &
                    (sym.sym.value == "then")).not) then {
                    util.syntax_error("elseif with no then.")
                }
                next()
                ebody := []
                if ((accept("lbrace")).not) then {
                    util.syntax_error("expected \{.")
                }
                next()
                if (sym.sym.line == lastToken.line) then {
                    minIndentLevel := sym.sym.linePos - 1
                } else {
                    minIndentLevel := minInd
                }
                while {(accept("rbrace")).not} do {
                    statement()
                    v := values.pop()
                    ebody.push(v)
                }
                next()
                newelse := []
                eif := ast.astif(econd, ebody, newelse)
                // Construct the inner "if" AST node, and then push it
                // inside the current "else" block.
                curelse.push(eif)
                // Update curelse to point to the new, empty, nested
                // else block.
                curelse := newelse
            }
            if (accept("identifier") & (sym.sym.value == "else")) then {
                next()
                if (accept("lbrace")) then {
                    // Just take all the statements and put them into
                    // curelse.
                    next()
                    if (sym.sym.line == lastToken.line) then {
                        minIndentLevel := sym.sym.linePos - 1
                    } else {
                        minIndentLevel := minInd
                    }
                    while {(accept("rbrace")).not} do {
                        statement()
                        v := values.pop()
                        curelse.push(v)
                    }
                    next()
                }
            }
            minIndentLevel := minInd - 1
            var o := ast.astif(cond, body, elseblock)
            values.push(o)
        } else {
            // Raise an error here, or it will spin nastily forever.
            util.syntax_error("if with no then")
        }
    }
}

// Accept a "for" statement. This is also a syntactic special case
// at the moment. It currently *requires* exactly one parameter.
method dofor() {
    if (accept("identifier") & (sym.sym.value == "for")) then {
        next()
        var over
        expression()
        over := values.pop()
        var body := []
        var variable
        var localMin
        var minInd := statementIndent + 1
        if (accept("identifier") & ((sym.sym.value == "each")
            | (sym.sym.value == "do"))) then {
            next()
            if (accept("lbrace")) then {
                next()
                identifier()
                variable := values.pop()
                if (accept("colon")) then {
                    next()
                    pushidentifier()
                    variable.type := values.pop()
                }
                if (accept("arrow")) then {
                    next()
                    localMin := minIndentLevel
                    if (sym.sym.line == lastToken.line) then {
                        minIndentLevel := sym.sym.linePos - 1
                    } else {
                        minIndentLevel := minInd
                    }
                    while {(accept("rbrace")).not} do {
                        statement()
                        var v := values.pop()
                        body.push(v)
                    }
                    next()
                }
            }
            var o := ast.astfor(over, variable, body)
            values.push(o)
            minIndentLevel := minInd - 1
        }
    }
}

// Accept a "while" statement as a syntactic special case. There is
// nothing particularly special about it compared to the last two.
method dowhile() {
    if (accept("identifier") & (sym.sym.value == "while")) then {
        var minInd := statementIndent + 1
        next()
        var cond
        if (accept("lbrace")) then {
            next()
            expression()
            cond := values.pop()
            if (accept("rbrace")) then {
                next()
            }
        }
        var body := []
        if (accept("identifier") & (sym.sym.value == "do")) then {
            next()
            if (accept("lbrace")) then {
                next()
                if (sym.sym.line == lastToken.line) then {
                    minIndentLevel := sym.sym.linePos - 1
                } else {
                    minIndentLevel := minInd
                }
                while {(accept("rbrace")).not} do {
                    statement()
                    var v := values.pop()
                    body.push(v)
                }
                next()
            }
            var o := ast.astwhile(cond, body)
            values.push(o)
        }
        minIndentLevel := minInd - 1
    }
}

// Accept an identifier. Handle "if", "while", and "for" specially by
// passing them on to the appropriate method above.
method identifier() {
    if (accept("identifier")) then {
        if (sym.sym.value == "if") then {
            doif()
        } elseif (sym.sym.value == "while") then {
                dowhile()
        } elseif (sym.sym.value == "for") then {
            dofor()
        } else {
            pushidentifier()
        }
    }
}

method prefixop() {
    if (accept("op")) then {
        var op := sym.sym.value
        var val
        next()
        if (accept("lparen")) then {
            next()
            expression()
            if (accept("rparen").not) then {
                util.syntax_error("expected rparen, have " ++ sym.sym.kind)
            }
            next()
            val := values.pop()
        } else {
            term()
            val := values.pop()
        }
        var mem := ast.astmember("prefix" ++ op, val)
        var call := ast.astcall(mem, [])
        values.push(call)
    }
}

// Accept a term. Terms consist only of single syntactic units and
// do not contain any operators or parentheses, unlike expression.
method term() {
    if (accept("num")) then {
        pushnum()
    } elseif (accept("string")) then {
        pushstring()
    } elseif (accept("octets")) then {
        pushoctets()
    } elseif (accept("identifier")) then {
        identifier()
    } elseif (accept("keyword") & (sym.sym.value == "object")) then {
        doobject()
    } elseif (accept("lbrace")) then {
        block()
    } elseif (accept("lsquare")) then {
        doarray()
    } elseif (accept("op")) then {
        // Prefix operator
        prefixop()
    }
}

// Accept an expression. Expressions may consist of parenthesised
// subexpressions or terms, which may be followed by method invocations
// (dotrest), postcircumfix square brackets, the rest of a method call,
// or an operator expression.
method expression() {
    if (accept("lparen")) then {
        next()
        expression()
        if (accept("rparen")) then {
            next()
        } else {
            util.syntax_error("expected rparen, have " ++ sym.sym.kind
                ++ "(" ++ sym.sym.value ++ ")")
        }
    } else {
        term()
    }
    dotrest()
    postfixsquare()
    callrest()
    expressionrest()
}

// Accept postcircumfix square brackets (as in x[y]) and replace the
// preceding expression with an index node into itself.
method postfixsquare() {
    if (accept("lsquare")) then {
        next()
        var expr := values.pop()
        expression()
        var index := values.pop()
        if (accept("rsquare")) then {
            next()
            var o := ast.astindex(expr, index)
            values.push(o)
        }
    }
}

// Calculate the precedence of an operator. In this case, only
// multiplication and division have nontrivial precedence. Used in
// expressionrest.
method oprec(o) {
    if (o == "*") then {
        return 10
    } elseif (o == "/") then {
        return 10
    }
    return 5
}

// Return the precedence of the operator at the top of the "ops" stack.
method toprec(ops) {
    if (ops.size > 0) then {
        var o := ops.at(ops.size - 1)
        return oprec(o)
    }
    0
}

// Process the rest of an operator expression using the shunting-yard
// algorithm. This method uses the oprec() and toprec() methods above to
// ensure the correct precedence, and treats all operators as
// left-associative.
method expressionrest() {
    if (accept("op")) then {
        var terms := [] // List of operands yet to be used
        var ops := [] // Operator stack
        var o
        var o2
        var tmp2
        var tmp := values.pop()
        terms.push(tmp)
        var prec
        var allarith := true // Consists only of arithmetic operators
        var opcount := 0
        var optype := "" // The single operator being used in this expression
        while {accept("op")} do {
            opcount := opcount + 1
            o := sym.sym.value
            next()
            prec := oprec(o)
            if ((o /= "*") & (o /= "/") & (o /= "+") & (o /= "-")) then {
                allarith := false
            }
            if ((optype /= "") & (optype /= o) & (allarith.not)) then {
                // If: this is not the first operator, it is not the same
                // as the last operator, and the expression has not been
                // entirely arithmetic, raise a syntax error.
                util.syntax_error("mixed operators without parentheses: "
                    ++ optype ++ " and " ++ o)
            }
            optype := o
            while {(ops.size > 0) & (prec <= toprec(ops))} do {
                // Do the shunting: for as long as the current operator
                // has lesser or equal precedence than the one on the
                // top of the stack, take the operator off the stack and
                // replace its two operands with the combined operator node.
                // This corresponds to left-associative operators only.
                o2 := ops.pop()
                tmp2 := terms.pop()
                tmp := terms.pop()
                tmp := ast.astop(o2, tmp, tmp2)
                terms.push(tmp)
            }
            ops.push(o)
            if (accept("lparen")) then {
                // When a parenthesis is found, take an expression from
                // *within* the parentheses and add it to the stack. Do
                // not delegate entirely to expression, because it will
                // then consume all the following operators and break
                // precedence. Possibly parenthesised expressions could
                // be allowed in term() above?
                next()
                expression()
                if (accept("rparen")) then {
                    next()
                } else {
                    util.syntax_error("expected rparen, have " ++ sym.sym.kind
                        ++ "(" ++ sym.sym.value ++ ")")
                }
            } else {
                term()
            }

            // Regardless of where the last value came from, it may have
            // method invocations, indexes, or method call happening to it,
            // which should be applied and the result put into the operands
            // list.
            dotrest()
            postfixsquare()
            callrest()
            tmp := values.pop()
            terms.push(tmp)
        }
        while {ops.size > 0} do {
            // Shunt off any remaining operators at the end
            o := ops.pop()
            tmp2 := terms.pop
            tmp := terms.pop
            tmp := ast.astop(o, tmp, tmp2)
            terms.push(tmp)
        }
        tmp := terms.pop()
        values.push(tmp)
        if (terms.size > 0) then {
            util.syntax_error("values left on term stack")
        }
    }
}

// Accept a member lookup with ".". This consumes the dot and
// a following identifier, and will pass along to further lookups or
// method calls on the result.
method dotrest() {
    if (accept("dot")) then {
        var lookuptarget := values.pop()
        next()
        if (accept("identifier")) then {
            var dro := ast.astmember(sym.sym.value, lookuptarget)
            values.push(dro)
            next()
            if (accept("dot")) then {
                dotrest()
            } elseif (accept("lparen")) then {
                callrest()
            } elseif (accept("lbrace")) then {
                callblockrest()
            }
        }
    }
}

// Accept a block, turning it into the argument to the immediately-preceding
// method.
method callblockrest() {
    if (accept("lbrace")) then {
        var meth := values.pop()
        expression()
        var arg := values.pop()
        var o := ast.astcall(meth, [arg])
        values.push(o)
    }
}

// Accept a method invocation indicated by parentheses. Unparenthesised
// method calls are left as "member" AST nodes and processed correctly at
// a later stage.
method callrest() {
    var meth
    var methn
    var tmp
    var ln := false
    var params := []
    var hadcall := false
    var tok := lastToken
    if (accept("lparen")) then {
        tok := sym.sym
        hadcall := true
        meth := values.pop()
        methn := meth.value
        next()
        values.push(object {
            var kind := "lparen"
            var register := ""
        })
        expression()
        while {accept("comma")} do {
            next()
            expression()
        }
        if (accept("rparen")) then {
            tok := sym.sym
            var tmpparams := []
            var n := values.pop()
            while {n.kind /= "lparen"} do {
                tmpparams.push(n)
                n := values.pop()
            }
            for (0..(tmpparams.size-1)) do { x ->
                var p := tmpparams.pop()
                params.push(p)
            }
            // All of the preceding has been an overly-complicated way of
            // obtaining the arguments to the method, which I think could
            // be done in a much simpler way now. TODO.
            ln := linenum
            next()
        }
    } elseif (accept("string")onLineOf(tok) | accept("num")onLineOf(tok)
        | (accept("identifier")onLineOf(tok) & ((sym.sym.value == "true")
                                   | (sym.sym.value == "false")))) then {
        tok := sym.sym
        hadcall := true
        meth := values.pop()
        methn := meth.value
        ln := linenum
        term()
        var ar := values.pop
        params.push(ar)
    }
    if (hadcall) then {
        if (accept("identifier")onLineOf(tok)) then {
            // Multi-part method name
            methn := callmprest(ast.astidentifier(methn, false), params, tok)
            if (meth.kind == "member") then {
                // callmprest loses this information, so restore
                // the member lookup (for x.between(3)and(10)-type
                // calls).
                meth := ast.astmember(methn.value, meth.in)
            } else {
                meth := methn
            }
        }
        tmp := ast.astcall(meth, params)
        values.push(tmp)
    }
    dotrest()
}

// Process the rest of a multi-part method name. Returns an identifier
// to replace the one passed in, in which each word is joined by "()",
// and updates params in place.
method callmprest(meth, params, tok) {
    var methname := meth.value
    var nxt
    var ln := linenum
    while {accept("identifier")onLineOf(tok)} do {
        // Each word must start on the same line as the preceding parameter
        // ended.
        methname := methname ++ "()"
        pushidentifier()
        nxt := values.pop
        methname := methname ++ nxt.value
        var isTerm := false
        if ((accept("lparen")).not & (accept("lbrace")).not
            & accept("string").not) then {
            util.syntax_error("multi-part method name parameters require ().")
        }
        if (accept("lbrace")onLineOf(tok) | accept("string")onLineOf(tok)
            | accept("num")onLineOf(tok)
            | (accept("identifier")onLineOf(tok) & ((sym.sym.value == "true")
                                       | (sym.sym.value == "false")))) then {
            isTerm := true
        } else {
            next()
        }
        if (accept("string")) then {
            ln := lastline
            term()
        } else {
            expression()
        }
        nxt := values.pop()
        params.push(nxt)
        if ((accept("rparen")).not & isTerm.not) then {
            // Currently, this rejects calls like:
            //   a(x) b(y,z) c(w)
            // That may not be necessary, though future varargs support
            // could be an issue.
            util.syntax_error("multi-part method name parameters must be single.")
        }
        if (accept("rparen") & isTerm.not) then {
            ln := lastline
            next()
        }
    }
    ast.astidentifier(methname, false)
}

// Accept a const declaration
method constdec() {
    if (accept("keyword") & (sym.sym.value == "const")) then {
        next()
        pushidentifier()
        var val := false
        var type := false
        var name := values.pop()
        if (accept("colon")) then {
            next()
            identifier()
            type := values.pop()
        }
        if (accept("bind")) then {
            next()
            expression()
            val := values.pop()
        } else {
            util.syntax_error("const declaration requires value")
        }
        var o := ast.astconstdec(name, val, type)
        values.push(o)
    }
}

// Accept a var declaration
method vardec() {
    if (accept("keyword") & (sym.sym.value == "var")) then {
        next()
        pushidentifier()
        var val := false
        var type := false
        var name := values.pop()
        if (accept("colon")) then {
            next()
            identifier()
            type := values.pop()
        }
        if (accept("bind")) then {
            next()
            expression()
            val := values.pop()
        }
        var o := ast.astvardec(name, val, type)
        values.push(o)
    }
}

// Accept a square-bracketed list literal like [1,2,3].
method doarray() {
    if (accept("lsquare")) then {
        next()
        values.push(object {
            var kind := "lsquare"
            var register := ""
        })
        expression()
        while {accept("comma")} do {
            next()
            expression()
        }
        if (accept("rsquare")) then {
            var tmpparams := []
            var n := values.pop()
            while {n.kind /= "lsquare"} do {
                tmpparams.push(n)
                n := values.pop()
            }
            var params := []
            for (0..(tmpparams.size-1)) do { x ->
                var p := tmpparams.pop()
                params.push(p)
            }
            // Again, the preceding is an overly complicated way of parsing
            // a comma-separated list and has a simpler replacement now. TODO
            var o := ast.astarray(params)
            values.push(o)
            next()
        } else {
            util.syntax_error("expected rsquare, got " ++ sym.sym.kind)
        }
    }
}

// Accept an object literal.
method doobject() {
    // doobject because "object" is a keyword
    if (accept("keyword") & (sym.sym.value == "object")) then {
        next()
        if (accept("lbrace")) then {
            values.push(object {
                var kind := "lbrace"
                var register := ""
            })
            next()
            var sz := values.size()
            while {(accept("rbrace")).not} do {
                // An object body contains zero or more var declarations,
                // const declarations, and method declarations. If anything
                // else appears before the closing brace, it is a syntax error.
                vardec()
                methoddec()
                constdec()
                if (values.size == sz) then {
                    util.syntax_error("did not consume anything in "
                        ++ "object declaration.")
                }
                sz := values.size
            }
            next()
            var rbody := []
            var n := values.pop()
            while {n.kind /= "lbrace"} do {
                rbody.push(n)
                n := values.pop()
            }
            var body := []
            for (0..(rbody.size-1)) do { x ->
                // Reorder the list
                var p := rbody.pop()
                body.push(p)
            }
            var o := ast.astobject(body)
            values.push(o)
        }
    }
}

// Accept a class declaration
// Class declarations are currently of the form:
//   class classname { param1, param2 ->
//     var x
//     method y(z) { ... }
//   }
method doclass() {
    if (accept("keyword") & (sym.sym.value == "class")) then {
        next()
        pushidentifier() // A class currently cannot be anonymous
        var cname := values.pop()
        if (accept("lbrace")) then {
            values.push(object {
                var kind := "lbrace"
                var register := ""
            })
            next()
            var params := []
            if (accept("identifier")) then {
                // We have a parameter list, because everything else that
                // can appear first in a class body is a keyword.
                pushidentifier()
                var pid := values.pop()
                if (accept("colon")) then {
                    next()
                    pushidentifier()
                    pid.type := values.pop()
                }
                params.push(pid)
                while {accept("comma")} do {
                    next()
                    pushidentifier()
                    pid := values.pop()
                    if (accept("colon")) then {
                        next()
                        pushidentifier()
                        pid.type := values.pop()
                    }
                    params.push(pid)
                }
                if (accept("arrow")) then {
                    next()
                } else {
                    util.syntax_error("expected ->.")
                }
            }
            var sz := values.size()
            while {(accept("rbrace")).not} do {
                // Body of the class, the same as the body of an object.
                vardec()
                methoddec()
                constdec()
                if (values.size == sz) then {
                    util.syntax_error("did not consume anything in "
                        ++ "class declaration.")
                }
                sz := values.size
            }
            next()
            var rbody := []
            var n := values.pop()
            while {n.kind /= "lbrace"} do {
                rbody.push(n)
                n := values.pop()
            }
            var body := []
            for (0..(rbody.size-1)) do { x ->
                var p := rbody.pop()
                body.push(p)
            }
            var o := ast.astclass(cname, params, body)
            values.push(o)
        }
    }
}

// Process the declaration of a multi-part method name. These follow
// mostly the same rules as calls, but aren't strictly enforced to be on
// a single line (because they are ended by "{" or "->"). This method
// returns a replacement method name identifier and modifies params in
// place.
method parsempmndecrest(meth, params) {
    var methname := meth.value
    var nxt
    while {accept("identifier")} do {
        methname := methname ++ "()"
        pushidentifier()
        nxt := values.pop
        methname := methname ++ nxt.value
        if ((accept("lparen")).not) then {
            util.syntax_error("multi-part method name parameters require ().")
        }
        next()
        pushidentifier()
        nxt := values.pop()
        if (accept("colon")) then {
            next()
            pushidentifier()
            var tp := values.pop()
            nxt.type := tp
        }
        params.push(nxt)
        if ((accept("rparen")).not) then {
            util.syntax_error("multi-part method name parameters must be single.")
        }
        next()
    }
    ast.astidentifier(methname, false)
}

// Accept a method declaration
method methoddec() {
    if (accept("keyword") & (sym.sym.value == "method")) then {
        next()
        pushidentifier()
        var meth := values.pop()
        if (accept("bind")) then {
            next()
            meth.value := meth.value ++ ":="
        } elseif (accept("op") & (meth.value == "prefix")) then {
            meth.value := meth.value ++ sym.sym.value
            next()
        }
        var rparams := []
        var params := []
        var type := false
        if (accept("lparen")) then {
            next()
            var id
            while {accept("identifier")} do {
                // Parse the parameter list, including optional type
                // annotations.
                pushidentifier()
                id := values.pop()
                type := false
                if (accept("colon")) then {
                    next()
                    if (accept("identifier")) then {
                        pushidentifier()
                        type := values.pop()
                    } else {
                        util.syntax_error("expected type after :.")
                    }
                }
                id.type := type
                params.push(id)
                if (accept("comma")) then {
                    next()
                } elseif ((accept("rparen")).not) then {
                    util.syntax_error("expected comma or rparen.")
                }
            }
            if (accept("rparen")) then {
                next()
                if (accept("identifier")) then {
                    // The presence of an identifier here means
                    // a multi-part method name.
                    meth := parsempmndecrest(meth, params)
                }
            }
        }
        if (accept("arrow")) then {
            // Return type
            next()
            pushidentifier()
            type := values.pop()
        } else {
            type := false
        }
        var body := []
        var stok := sym.sym
        var localMin
        if (accept("lbrace")) then {
            next()
            localMin := minIndentLevel
            if (sym.sym.line == stok.line) then {
                minIndentLevel := sym.sym.linePos - 1
            } else {
                minIndentLevel := stok.indent + 1
            }
            values.push(object {
                var kind := "lbrace"
                var register := ""
            })
            statement()
            var s := values.pop()
            while {s.kind /= "lbrace"} do {
                // The body is a sequence of statements, and
                // the method ends when no further statement
                // is found.
                body.push(s)
                statement()
                s := values.pop()
            }
            if (accept("rbrace")) then {
                next()
            } else {
                util.syntax_error("No statement but not end of "
                    ++ meth.value ++ ". Have " ++ sym.sym.kind ++ ".")
            }
            minIndentLevel := localMin
        } else {
            util.syntax_error("No body in method declaration for " ++
                meth.value)
        }
        var o := ast.astmethod(meth, params, body, type)
        values.push(o)
    }
}

// Accept an import statement. import takes a single identifier
// following, as in "import parser".
method doimport() {
    if (accept("keyword") & (sym.sym.value == "import")) then {
        next()
        identifier()
        var p := values.pop()
        var o := ast.astimport(p)
        values.push(o)
    }
}

// Accept a return statement. return takes a mandatory argument,
// of the form "return x". x may be any expression.
method doreturn() {
    if (accept("keyword") & (sym.sym.value == "return")) then {
        next()
        expression()
        var p := values.pop()
        var o := ast.astreturn(p)
        values.push(o)
    }
}

// Accept a statement. A statement is any of the above that may exist
// at the top level, and includes expressions.
// A statement may also be a bind statement x := y, which creates a
// bind AST node out of the expressions on either side (which at this point
// can be any arbitrary expression).
method statement() {
    statementIndent := sym.sym.indent
    if ((sym.sym.kind == "rbrace") | (sym.sym.kind == "rparen")
        | (sym.sym.kind == "rsquare")) then {
        // pass
    } elseif (sym.sym.indent < minIndentLevel) then {
        if ((sym.sym.linePos - 1) /= minIndentLevel) then {
            util.syntax_error("block and indentation inconsistent "
                ++ "for token " ++ sym.sym.kind ++ ": " ++ sym.sym.value ++ "; "
                ++ "indentation is " ++ sym.sym.indent ++ ", must be at least "
                ++ minIndentLevel)
        }
    } elseif (sym.sym.indent > minIndentLevel) then {
        minIndentLevel := sym.sym.indent
    }
    if (accept("keyword")) then {
        if (sym.sym.value == "var") then {
            vardec()
        } elseif (sym.sym.value == "const") then {
            constdec()
        } elseif (sym.sym.value == "method") then {
            methoddec()
        } elseif (sym.sym.value == "import") then {
            doimport()
        } elseif (sym.sym.value == "class") then {
            doclass()
        } elseif (sym.sym.value == "return") then {
            doreturn()
        } else {
            expression()
        }
    } else {
        expression()
        if (accept("bind")) then {
            var dest := values.pop()
            next()
            expression()
            var val := values.pop()
            var o := ast.astbind(dest, val)
            values.push(o)
        }
    }
    if (accept("semicolon")) then {
        next()
    }
}

// Parse the given list of tokens, returning a list of AST nodes
// corresponding to it.
method parse(toks) {
    util.log_verbose("processing tokens.")
    var otoks := toks
    sym.sym := toks[0]
    tokens := []
    for (0..(otoks.size-1)) do { i ->
        var o := otoks.pop()
        tokens.push(o)
    }
    util.log_verbose("parsing.")
    linenum := 1
    next()
    var oldlength := tokens.size + 0
    if (tokens.size == 0) then {
        // Single token is ignored otherwise
        statement()
    }
    while {tokens.size > 0} do {
        statement()
        if (tokens.size == oldlength) then {
            var nxtToks := ""
            for (0..5) do {i->
                if (i < tokens.size) then {
                    var t := tokens.at(tokens.size - i - 1)
                    nxtToks := nxtToks ++ t.kind ++ ": " ++ t.value ++ ", "
                }
            }
            var lstAST := ""
            for (0..5) do {i->
                if (values.size > 0) then {
                    var t := values.pop
                    print(t.kind)
                    print(t.pretty(2))
                    lstAST := t.pretty(1) ++ "\n" ++ lstAST
                }
            }
            util.syntax_error("No token consumed. Have " ++ sym.sym.kind
                ++ ": " ++ sym.sym.value ++ ". Recent AST:\n"
                ++ lstAST ++ "\nNext tokens: " ++ nxtToks)
        }
        oldlength := tokens.size + 0
    }
    values
}
