import io
import unicode
import sys
import ast
import genllvm
genllvm.setast(ast)

var tmp := 0
var linenum := 1
var modules := []
var staticmodules := []

var infile := io.input
var outfile := io.output
var modname := "main"
var runmode := "build"
var buildtype := "bc"
var gracelibPath := "gracelib.o"

var verbosity := 30

if (argv.size > 1) then {
    var ai := 1
    var arg
    while {ai < argv.size} do {
        arg := argv[ai]
        if (arg.at(0) == "-") then {
            if (arg == "-o") then {
                ai := ai + 1
                outfile := io.open(argv[ai], "w")
            }
            if (arg == "--verbose") then {
                verbosity := 40
            }
            if (arg == "--make") then {
                runmode := "make"
            }
            if (arg == "--run") then {
                buildtype := "run"
                runmode := "make"
            }
            if (arg == "--native") then {
                buildtype := "native"
            }
            if (arg == "--module") then {
                ai := ai + 1
                modname := argv[ai]
            }
            if (arg == "--gracelib") then {
                ai := ai + 1
                gracelibPath := argv[ai]
            }
            if (arg == "--parse") then {
                buildtype := "parse"
            }
        } else {
            var filename := arg
            infile := io.open(filename, "r")
            if modname == "main" then {
                modname := ""
                var seendot := false
                for (filename) do { c->
                    if (c == ".") then {
                        seendot := true
                    }
                    if (seendot.not) then {
                        modname := modname ++ c
                    }
                }
            }
            if (outfile == io.output) then {
                outfile := io.open(modname ++ ".ll", "w")
            }
        }
        ai := ai + 1
    }
}
genllvm.setverbosity(verbosity)

method log_verbose(s) {
    if (verbosity >= 40) then {
        io.error.write("minigrace: ")
        io.error.write(sys.cputime.asString)
        io.error.write("/")
        io.error.write(sys.elapsed.asString)
        io.error.write(": ")
        io.error.write(s)
        io.error.write("\n")
    }
}

method outprint(s) {
    outfile.write(s)
    outfile.write("\n")
}
method syntax_error(s) {
    io.error.write("Syntax error around line " ++ linenum ++ ": ")
    io.error.write(s)
    io.error.write("\l")
    raise("Syntax error: "++ s)
}
method hexdecchar(c) {
    var chars := ["0", "1", "2", "3", "4", "5", "6", "7", "8",
                 "9", "a", "b", "c", "d", "e", "f"]
    var ret := 0
    for (0..15) do {i->
        if (chars.at(i) == c) then {
            ret := i
        }
    }
    ret
}

class IdentifierToken { s ->
    var kind := "identifier"
    var value := s
}
class StringToken { s ->
    var kind := "string"
    var value := s
}
class OctetsToken { s ->
    var kind := "octets"
    var value := s
}
class LBraceToken {
    var kind := "lbrace"
    var value := "{"
}
var LBraceTokenV := LBraceToken.new
class RBraceToken {
    var kind := "rbrace"
    var value := "}"
}
var RBraceTokenV := RBraceToken.new
class LParenToken {
    var kind := "lparen"
    var value := "("
}
var LParenTokenV := LParenToken.new
class RParenToken {
    var kind := "rparen"
    var value := ")"
}
var RParenTokenV := RParenToken.new
class LSquareToken {
    var kind := "lsquare"
    var value := "["
}
var LSquareTokenV := LSquareToken.new
class RSquareToken {
    var kind := "rsquare"
    var value := "]"
}
var RSquareTokenV := RSquareToken.new
class CommaToken {
    var kind := "comma"
    var value := ","
}
var CommaTokenV := CommaToken.new
class ColonToken {
    var kind := "colon"
    var value := ":"
}
var ColonTokenV := ColonToken.new
class DotToken {
    var kind := "dot"
    var value := "."
}
var DotTokenV := DotToken.new
class NumToken { v ->
    var kind := "num"
    var value := v
}
class KeywordToken { v ->
    var kind := "keyword"
    var value := v
}
class OpToken { v ->
    var kind := "op"
    var value := v
}
class ArrowToken {
    var kind := "arrow"
    var value := "->"
}
var ArrowTokenV := ArrowToken.new
class BindToken {
    var kind := "bind"
    var value := ":="
}
var BindTokenV := BindToken.new


method modechange(tokens, mode, accum) {
    var done := false
    var tok := 0
    if ((mode /= "n") | (accum.size > 0)) then {
        if (mode == "i") then {
            tok := IdentifierToken.new(accum)
            if ((accum == "object") | (accum == "method")
                | (accum == "var") | (accum == "const")
                | (accum == "import") | (accum == "class")
                | (accum == "return")) then {
                tok := KeywordToken.new(accum)
            }
            tokens.push(tok)
            done := true
        }
        if (mode == "\"") then {
            tok := StringToken.new(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == "x") then {
            tok := OctetsToken.new(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == ",") then {
            tok := CommaTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == ".") then {
            tok := DotTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "{") then {
            tok := LBraceTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "}") then {
            tok := RBraceTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "(") then {
            tok := LParenTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == ")") then {
            tok := RParenTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "[") then {
            tok := LSquareTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "]") then {
            tok := RSquareTokenV
            tokens.push(tok)
            done := true
        }
        if (mode == "m") then {
            tok := NumToken.new(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == "o") then {
            tok := OpToken.new(accum)
            if (accum == "->") then {
                tok := ArrowTokenV
            }
            if (accum == ":=") then {
                tok := BindTokenV
            }
            if (accum == ":") then {
                tok := ColonTokenV
            }
            tokens.push(tok)
            done := true
        }
        if (mode == "n") then {
            done := true
        }
        if (mode == "c") then {
            done := true
        }
        if (done) then {
            //print(mode, accum, tokens)
        } else {
            syntax_error("Lexing error: no handler for mode " ++ mode ++
                " with accum " ++ accum)
        }
    }
}
log_verbose("reading source.")
var input := infile.read()

method isidentifierchar(ov) {
    if (unicode.isLetter(ov) | unicode.isNumber(ov)
        | (ov == 95) | (ov == 39)) then {
        // 95 is _, 39 is '
        true
    } else {
        false
    }
}
method isoperatorchar(c, ordval) {
    var ret := false
    if ((c == "-") | (c == "&") | (c == "|") | (c == ":") | (c == "%")
        | (c == "*") | (c == "/")) then {
        ret := true
    } elseif (unicode.isSymbolMathematical(ordval)) then {
        ret := true
    }
    ret
}

var tokens := []
var mode := "n"
var newmode := mode
var instr := false
var accum := ""
var escaped := false
var prev := ""
var unichars := 0
var codepoint := 0
log_verbose("lexing.")
for (input) do { c ->
    var ct := ""
    var ordval := c.ord
    if ((unicode.isSeparator(ordval) & (ordval /= 32) & (ordval /= 8232)) |
        (ordval == 9)) then {
        syntax_error("illegal whitespace in input: " ++ ordval ++ ", "
            ++ unicode.name(c))
    }
    if (unicode.isControl(ordval) & (ordval /= 10) & (ordval /= 13)) then {
        syntax_error("illegal control character in input: #" ++ ordval)
    }
    if (instr) then {

    } elseif (mode /= "c") then {
        if (c == " ") then {
            newmode := "n"
        }
        if (c == "\"") then {
            newmode := "\""
            instr := true
            if prev == "x" then {
                newmode := "x"
                mode := "n"
            }
        }
        ct := isidentifierchar(ordval)
        if (ct) then {
            newmode := "i"
        }
        ct := ((ordval >= 48) & (ordval <=57))
        if (ct & (mode /= "i")) then {
            newmode := "m"
        }
        if (isoperatorchar(c, ordval)) then {
            newmode := "o"
        }
        if ((c == "(") | (c == ")") | (c == ",") | (c == ".")
            | (c == "{") | (c == "}") | (c == "[") | (c == "]")) then {
            newmode := c
        }
        if ((c == ".") & (accum == ".")) then {
            mode := "o"
            newmode := mode
        }
        if ((c == "/") & (accum == "/")) then {
            mode := "c"
            newmode := mode
        }
    }
    if ((mode == "x") & (c == "\"") & (escaped.not)) then {
        newmode := "n"
        instr := false
    }
    if ((mode == "\"") & (c == "\"") & (escaped.not)) then {
        newmode := "n"
        instr := false
    }
    if (newmode /= mode) then {
        modechange(tokens, mode, accum)
        mode := newmode
        if (instr) then {
            accum := ""
        } else {
            accum := c
        }
        if ((mode == "(") | (mode == ")") | (mode == "[")
            | (mode == "]")) then {
            modechange(tokens, mode, accum)
            mode := "n"
            newmode := "n"
            accum := ""
        }
    } elseif (instr) then {
        if c == "\n" then {
            syntax_error("Newlines not permitted in string literals")
        }
        if (escaped) then {
            if ((c == "l") | (c == "n")) then {
                accum := accum ++ "\n"
            } elseif (c == "u") then {
                unichars := 4
                codepoint := 0
            } elseif (c == "U") then {
                unichars := 6
                codepoint := 0
            } else {
                accum := accum ++ c
            }
            escaped := false
        } elseif (c == "\\") then {
            escaped := true
        } elseif (unichars > 0) then {
            unichars := unichars - 1
            codepoint := codepoint * 16
            codepoint := codepoint + hexdecchar(c)
            if (unichars == 0) then {
                accum := accum ++ unicode.create(codepoint)
            }
        } else {
            accum := accum ++ c
        }
    } elseif (c == "\n") then {
        modechange(tokens, mode, accum)
        mode := "n"
        newmode := "n"
        accum := ""
    } else {
        accum := accum ++ c
    }
    if (c == "\n") then {
        linenum := linenum + 1
        tokens.push(object {
            var kind := "line"
            var value := linenum + 0
        })
    }
    prev := c
}
modechange(tokens, mode, accum)

var lastline := 0
var values := []
var sym := object {
    var sym := tokens[0]
}
method next() {
    if (tokens.size > 0) then {
        if (sym.sym.kind /= "line") then {
            lastline := linenum
        }
        sym.sym := tokens.pop()
        if ((sym.sym.kind == "line") & (tokens.size > 0)) then {
            var l := sym.sym.value
            if l /= linenum then {
                linenum := l
                next()
            }
        }
    } else {
        sym.sym := object { var kind := "eof" }
    }
}

method accept(t) {
    sym.sym.kind == t
}
method pushnum() {
    var o := ast.astnum(sym.sym.value)
    values.push(o)
    next()
}
method pushoctets() {
    var o := ast.astoctets(sym.sym.value)
    values.push(o)
    next()
}
method pushstring() {
    var o := ast.aststring(sym.sym.value)
    values.push(o)
    next()
}
method pushidentifier() {
    var o := ast.astidentifier(sym.sym.value, false)
    values.push(o)
    next()
}
method block() {
    if (accept("lbrace")) then {
        next()
        var ident1
        var s := sym.sym
        var tmp
        var params := []
        var body := []
        var havearrow := true
        var found := false
        var i := 0
        var toks := tokens
        // TODO This is a massive hack.
        for (0..30) do { i->
            if (i < (toks.size-1)) then {
                var t := toks.at((toks.size - i) - 1)
                if ((t.kind /= "identifier") & (t.kind /= "comma")
                    & (t.kind /= "arrow") & (t.kind /= "colon")
                    & found.not) then {
                    havearrow := false
                }
                if (t.kind == "arrow") then {
                    found := true
                }
            }
        }
        if (havearrow & accept("identifier")) then {
            pushidentifier()
            ident1 := values.pop()
            if (accept("comma") | accept("arrow") | accept("colon")) then {
                // It's a parameterised block
                if (accept("colon")) then {
                    next()
                    pushidentifier()
                    ident1.type := values.pop()
                }
                params.push(ident1)
                while {accept("comma")} do {
                    next()
                    pushidentifier()
                    ident1 := values.pop()
                    if (accept("colon")) then {
                        next()
                        pushidentifier()
                        ident1.type := values.pop()
                    }
                    params.push(ident1)
                }
                if ((accept("arrow")).not) then {
                    syntax_error("block parameter list not terminated ->.")
                }
                next()
            }
        }
        if (accept("arrow")) then {
            next()
        }
        var ln := values.size
        while {(accept("rbrace")).not} do {
            statement()
            if (ln == values.size) then {
                syntax_error("expected statement, have " ++ sym.sym.kind)
            }
            tmp := values.pop()
            body.push(tmp)
        }
        next()
        var o := ast.astblock(params, body)
        values.push(o)
    }
}
method doif() {
    if (accept("identifier") & (sym.sym.value == "if")) then {
        next()
        expression()
        var cond := values.pop()
        var body := []
        var elseblock := []
        var curelse := elseblock
        var v
        if (accept("identifier") & (sym.sym.value == "then")) then {
            next()
            if (accept("lbrace")) then {
                next()
                while {(accept("rbrace")).not} do {
                    statement()
                    v := values.pop()
                    body.push(v)
                }
                next()
            }
            var econd
            var eif
            var newelse
            var ebody
            while {accept("identifier") & (sym.sym.value == "elseif")} do {
                next()
                expression()
                econd := values.pop()
                if ((accept("identifier") &
                    (sym.sym.value == "then")).not) then {
                    syntax_error("elseif with no then.")
                }
                next()
                ebody := []
                if ((accept("lbrace")).not) then {
                    syntax_error("expected {.")
                }
                next()
                while {(accept("rbrace")).not} do {
                    statement()
                    v := values.pop()
                    ebody.push(v)
                }
                next()
                newelse := []
                eif := ast.astif(econd, ebody, newelse)
                curelse.push(eif)
                curelse := newelse
            }
            if (accept("identifier") & (sym.sym.value == "else")) then {
                next()
                if (accept("lbrace")) then {
                    next()
                    while {(accept("rbrace")).not} do {
                        statement()
                        v := values.pop()
                        curelse.push(v)
                    }
                    next()
                }
            }
            var o := ast.astif(cond, body, elseblock)
            values.push(o)
        } else {
            syntax_error("if with no then")
        }
    }
}
method dofor() {
    if (accept("identifier") & (sym.sym.value == "for")) then {
        next()
        var over
        expression()
        over := values.pop()
        var body := []
        var variable
        if (accept("identifier") & ((sym.sym.value == "each")
            | (sym.sym.value == "do"))) then {
            next()
            if (accept("lbrace")) then {
                next()
                identifier()
                variable := values.pop()
                if (accept("colon")) then {
                    next()
                    pushidentifier()
                    variable.type := values.pop()
                }
                if (accept("arrow")) then {
                    next()
                    while {(accept("rbrace")).not} do {
                        statement()
                        var v := values.pop()
                        body.push(v)
                    }
                    next()
                }
            }
            var o := ast.astfor(over, variable, body)
            values.push(o)
        }
    }
}
method dowhile() {
    if (accept("identifier") & (sym.sym.value == "while")) then {
        next()
        var cond
        if (accept("lbrace")) then {
            next()
            expression()
            cond := values.pop()
            if (accept("rbrace")) then {
                next()
            }
        }
        var body := []
        if (accept("identifier") & (sym.sym.value == "do")) then {
            next()
            if (accept("lbrace")) then {
                next()
                while {(accept("rbrace")).not} do {
                    statement()
                    var v := values.pop()
                    body.push(v)
                }
                next()
            }
            var o := ast.astwhile(cond, body)
            values.push(o)
        }
    }
}
method identifier() {
    if (accept("identifier")) then {
        if (sym.sym.value == "if") then {
            doif()
        } elseif (sym.sym.value == "while") then {
                dowhile()
        } elseif (sym.sym.value == "for") then {
            dofor()
        } else {
            pushidentifier()
        }
    }
}
method term() {
    if (accept("num")) then {
        pushnum()
    } elseif (accept("string")) then {
        pushstring()
    } elseif (accept("octets")) then {
        pushoctets()
    } elseif (accept("identifier")) then {
        identifier()
    } elseif (accept("keyword") & (sym.sym.value == "object")) then {
        doobject()
    } elseif (accept("lbrace")) then {
        block()
    } elseif (accept("lsquare")) then {
        doarray()
    }
}
method expression() {
    if (accept("lparen")) then {
        next()
        expression()
        if (accept("rparen")) then {
            next()
        } else {
            syntax_error("expected rparen, have " ++ sym.sym.kind
                ++ "(" ++ sym.sym.value ++ ")")
        }
    } else {
        term()
    }
    dotrest()
    postfixsquare()
    callrest()
    expressionrest()
}
method postfixsquare() {
    if (accept("lsquare")) then {
        next()
        var expr := values.pop()
        expression()
        var index := values.pop()
        if (accept("rsquare")) then {
            next()
            var o := ast.astindex(expr, index)
            values.push(o)
        }
    }
}
method oprec(o) {
    if (o == "*") then {
        return 10
    } elseif (o == "/") then {
        return 10
    }
    return 5
}
method toprec(ops) {
    if (ops.size > 0) then {
        var o := ops.at(ops.size - 1)
        return oprec(o)
    }
    0
}

// Shunting-yard algorithm
method expressionrest() {
    if (accept("op")) then {
        var terms := []
        var ops := []
        var o
        var o2
        var tmp2
        var tmp := values.pop()
        terms.push(tmp)
        var prec
        var allarith := true
        var opcount := 0
        var optype := ""
        while {accept("op")} do {
            opcount := opcount + 1
            o := sym.sym.value
            next()
            prec := oprec(o)
            if ((o /= "*") & (o /= "/") & (o /= "+") & (o /= "-")) then {
                allarith := false
            }
            if ((optype /= "") & (optype /= o) & (allarith.not)) then {
                syntax_error("mixed operators without parentheses: "
                    ++ optype ++ " and " ++ o)
            }
            optype := o
            while {(ops.size > 0) & (prec <= toprec(ops))} do {
                o2 := ops.pop()
                tmp2 := terms.pop()
                tmp := terms.pop()
                tmp := ast.astop(o2, tmp, tmp2)
                terms.push(tmp)
            }
            ops.push(o)
            if (accept("lparen")) then {
                expression()
            } else {
                term()
                dotrest()
                postfixsquare()
                callrest()
            }
            tmp := values.pop()
            terms.push(tmp)
        }
        while {ops.size > 0} do {
            o := ops.pop()
            tmp2 := terms.pop
            tmp := terms.pop
            tmp := ast.astop(o, tmp, tmp2)
            terms.push(tmp)
        }
        tmp := terms.pop()
        values.push(tmp)
        if (terms.size > 0) then {
            syntax_error("values left on term stack")
        }
    }
}
method dotrest() {
    if (accept("dot")) then {
        var lookuptarget := values.pop()
        next()
        if (accept("identifier")) then {
            var dro := ast.astmember(sym.sym.value, lookuptarget)
            values.push(dro)
            next()
            if (accept("dot")) then {
                dotrest()
            } elseif (accept("lparen")) then {
                callrest()
            } elseif (accept("lbrace")) then {
                callblockrest()
            }
        }
    }
}
method callblockrest() {
    if (accept("lbrace")) then {
        var meth := values.pop()
        expression()
        var arg := values.pop()
        var o := ast.astcall(meth, [arg])
        values.push(o)
    }
}
method callrest() {
    if (accept("lparen")) then {
        var meth := values.pop()
        var methn := meth.value
        next()
        values.push(object {
            var kind := "lparen"
            var register := ""
        })
        expression()
        while {accept("comma")} do {
            next()
            expression()
        }
        if (accept("rparen")) then {
            var tmpparams := []
            var n := values.pop()
            while {n.kind /= "lparen"} do {
                tmpparams.push(n)
                n := values.pop()
            }
            var params := []
            for (0..(tmpparams.size-1)) do { x ->
                var p := tmpparams.pop()
                params.push(p)
            }
            var ln := linenum
            next()
            if ((linenum == ln) & accept("identifier")) then {
                methn := callmprest(ast.astidentifier(methn, false), params)
                if (meth.kind == "member") then {
                    meth := ast.astmember(methn.value, meth.in)
                } else {
                    meth := methn
                }
            }
            var o := ast.astcall(meth, params)
            values.push(o)
        }
    }
    dotrest()
}
method callmprest(meth, params) {
    var methname := meth.value
    var nxt
    var ln := linenum
    while {accept("identifier") & (ln == linenum)} do {
        methname := methname ++ "()"
        pushidentifier()
        nxt := values.pop
        methname := methname ++ nxt.value
        var isblock := false
        if ((accept("lparen")).not & (accept("lbrace")).not) then {
            syntax_error("multi-part method name parameters require ().")
        }
        if (accept("lbrace")) then {
            isblock := true
        } else {
            next()
        }
        expression()
        nxt := values.pop()
        params.push(nxt)
        if ((accept("rparen")).not & isblock.not) then {
            syntax_error("multi-part method name parameters must be single.")
        }
        ln := lastline
        if (accept("rparen")) then {
            next()
        }
    }
    ast.astidentifier(methname, false)
}
method constdec() {
    if (accept("keyword") & (sym.sym.value == "const")) then {
        next()
        pushidentifier()
        var val
        var type
        var name := values.pop()
        if (accept("colon")) then {
            next()
            identifier()
            type := values.pop()
        }
        if (accept("bind")) then {
            next()
            expression()
            val := values.pop()
        } else {
            syntax_error("const declaration requires value")
        }
        var o := ast.astconstdec(name, val, type)
        values.push(o)
    }
}
method vardec() {
    if (accept("keyword") & (sym.sym.value == "var")) then {
        next()
        pushidentifier()
        var val
        var type
        var name := values.pop()
        if (accept("colon")) then {
            next()
            identifier()
            type := values.pop()
        }
        if (accept("bind")) then {
            next()
            expression()
            val := values.pop()
        }
        var o := ast.astvardec(name, val, type)
        values.push(o)
    }
}
method doarray() {
    if (accept("lsquare")) then {
        next()
        values.push(object {
            var kind := "lsquare"
            var register := ""
        })
        expression()
        while {accept("comma")} do {
            next()
            expression()
        }
        if (accept("rsquare")) then {
            var tmpparams := []
            var n := values.pop()
            while {n.kind /= "lsquare"} do {
                tmpparams.push(n)
                n := values.pop()
            }
            var params := []
            for (0..(tmpparams.size-1)) do { x ->
                var p := tmpparams.pop()
                params.push(p)
            }
            var o := ast.astarray(params)
            values.push(o)
            next()
        } else {
            syntax_error("expected rsquare, got " ++ sym.sym.kind)
        }
    }
}
method doobject() {
    // doobject because "object" is a keyword
    if (accept("keyword") & (sym.sym.value == "object")) then {
        next()
        if (accept("lbrace")) then {
            values.push(object {
                var kind := "lbrace"
                var register := ""
            })
            next()
            var sz := values.size()
            while {(accept("rbrace")).not} do {
                vardec()
                methoddec()
                constdec()
                if (values.size == sz) then {
                    syntax_error("did not consume anything in "
                        ++ "object declaration.")
                }
                sz := values.size
            }
            next()
            var rbody := []
            var n := values.pop()
            while {n.kind /= "lbrace"} do {
                rbody.push(n)
                n := values.pop()
            }
            var body := []
            for (0..(rbody.size-1)) do { x ->
                var p := rbody.pop()
                body.push(p)
            }
            var o := ast.astobject(body)
            values.push(o)
        }
    }
}
method doclass() {
    if (accept("keyword") & (sym.sym.value == "class")) then {
        next()
        pushidentifier()
        var cname := values.pop()
        if (accept("lbrace")) then {
            values.push(object {
                var kind := "lbrace"
                var register := ""
            })
            next()
            var params := []
            if (accept("identifier")) then {
                pushidentifier()
                var pid := values.pop()
                if (accept("colon")) then {
                    next()
                    pushidentifier()
                    pid.type := values.pop()
                }
                params.push(pid)
                while {accept("comma")} do {
                    next()
                    pushidentifier()
                    pid := values.pop()
                    if (accept("colon")) then {
                        next()
                        pushidentifier()
                        pid.type := values.pop()
                    }
                    params.push(pid)
                }
                if (accept("arrow")) then {
                    next()
                } else {
                    syntax_error("expected ->.")
                }
            }
            var sz := values.size()
            while {(accept("rbrace")).not} do {
                vardec()
                methoddec()
                constdec()
                if (values.size == sz) then {
                    syntax_error("did not consume anything in "
                        ++ "class declaration.")
                }
                sz := values.size
            }
            next()
            var rbody := []
            var n := values.pop()
            while {n.kind /= "lbrace"} do {
                rbody.push(n)
                n := values.pop()
            }
            var body := []
            for (0..(rbody.size-1)) do { x ->
                var p := rbody.pop()
                body.push(p)
            }
            var o := ast.astclass(cname, params, body)
            values.push(o)
        }
    }
}
method parsempmndecrest(meth, params) {
    var methname := meth.value
    var nxt
    while {accept("identifier")} do {
        methname := methname ++ "()"
        pushidentifier()
        nxt := values.pop
        methname := methname ++ nxt.value
        if ((accept("lparen")).not) then {
            syntax_error("multi-part method name parameters require ().")
        }
        next()
        pushidentifier()
        nxt := values.pop()
        if (accept("colon")) then {
            next()
            pushidentifier()
            var tp := values.pop()
            nxt.type := tp
        }
        params.push(nxt)
        if ((accept("rparen")).not) then {
            syntax_error("multi-part method name parameters must be single.")
        }
        next()
    }
    ast.astidentifier(methname, false)
}
method methoddec() {
    if (accept("keyword") & (sym.sym.value == "method")) then {
        next()
        pushidentifier()
        var meth := values.pop()
        var rparams := []
        if (accept("lparen")) then {
            next()
            var params := []
            var id
            var type
            while {accept("identifier")} do {
                pushidentifier()
                id := values.pop()
                type := false
                if (accept("colon")) then {
                    next()
                    if (accept("identifier")) then {
                        pushidentifier()
                        type := values.pop()
                    } else {
                        syntax_error("expected type after :.")
                    }
                }
                id.type := type
                params.push(id)
                if (accept("comma")) then {
                    next()
                } elseif ((accept("rparen")).not) then {
                    syntax_error("expected comma or rparen.")
                }
            }
            if (accept("rparen")) then {
                next()
                if (accept("identifier")) then {
                    meth := parsempmndecrest(meth, params)
                }
                if (accept("arrow")) then {
                    next()
                    pushidentifier()
                    type := values.pop()
                } else {
                    type := false
                }
                var body := []
                if (accept("lbrace")) then {
                    next()
                    values.push(object {
                        var kind := "lbrace"
                        var register := ""
                    })
                    statement()
                    var s := values.pop()
                    while {s.kind /= "lbrace"} do {
                        body.push(s)
                        statement()
                        s := values.pop()
                    }
                    if (accept("rbrace")) then {
                        next()
                    } else {
                        syntax_error("No statement but not end of "
                            ++ meth.value ++ ". Have " ++ sym.sym.kind ++ ".")
                    }
                } else {
                    syntax_error("No body in method declaration for " ++
                        meth.value)
                }
                var o := ast.astmethod(meth, params, body, type)
                values.push(o)
            }
        }
    }
}
method doimport() {
    if (accept("keyword") & (sym.sym.value == "import")) then {
        next()
        identifier()
        var p := values.pop()
        var o := ast.astimport(p)
        values.push(o)
    }
}
method doreturn() {
    if (accept("keyword") & (sym.sym.value == "return")) then {
        next()
        expression()
        var p := values.pop()
        var o := ast.astreturn(p)
        values.push(o)
    }
}
method statement() {
    if (accept("keyword")) then {
        if (sym.sym.value == "var") then {
            vardec()
        } elseif (sym.sym.value == "method") then {
            methoddec()
        } elseif (sym.sym.value == "import") then {
            doimport()
        } elseif (sym.sym.value == "class") then {
            doclass()
        } elseif (sym.sym.value == "return") then {
            doreturn()
        } else {
            expression()
        }
    } else {
        expression()
        if (accept("bind")) then {
            var dest := values.pop()
            next()
            expression()
            var val := values.pop()
            var o := ast.astbind(dest, val)
            values.push(o)
        }
    }
}
log_verbose("processing tokens.")
var otoks := tokens
tokens := []
for (0..(otoks.size-1)) do { i ->
    var o := otoks.pop()
    tokens.push(o)
}
log_verbose("parsing.")
linenum := 1
next()
var oldlength := tokens.size + 0
if (tokens.size == 0) then {
    // Single token is ignored otherwise
    statement()
}
while {tokens.size > 0} do {
    statement()
    if (tokens.size == oldlength) then {
        var next := []
        for (0..5) do {i->
            if (i < tokens.size) then {
                next.push(tokens.at(i))
            }
        }
        syntax_error("No token consumed. Next tokens: " ++ next)
    }
    oldlength := tokens.size + 0
}
if (buildtype == "parse") then {
    for (values) do { v->
        print(v.pretty(0))
    }
    sys.exit(0)
}
log_verbose("compiling.")

genllvm.compile(values, outfile, modname, runmode, buildtype, gracelibPath)
log_verbose("done")
