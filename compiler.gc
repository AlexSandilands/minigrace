import io

var tmp := 0
var linenum := 1
var modules := []

var infile := io.input
var outfile := io.output
var modname := "main"

if argv.length > 1 then {
    var ai := 1
    var arg
    while {ai < argv.length} do {
        arg := argv[ai]
        if arg == "-o" then {
            ai := ai + 1
            outfile := io.open(argv[ai], "w")
        } else {
            var filename := arg
            infile := io.open(filename, "r")
            modname := ""
            var seendot := false
            for filename each { c->
                if c == "." then {
                    seendot := true
                }
                if seendot.not then {
                    modname := modname ++ c
                }
            }
            if outfile == io.output then {
                outfile := io.open(modname ++ ".ll", "w")
            }
        }
        ai := ai + 1
    }
}

method outprint(s) {
    outfile.write(s)
    outfile.write("\n")
}
method syntax_error(s) {
    io.error.write("Syntax error around line " ++ linenum ++ ": ")
    io.error.write(s)
    io.error.write("\l")
    raise("Syntax error: "++ s)
}

method identifiertok(s) {
    object {
        var type := "identifier"
        var value := s
    }
}
method stringtok(s) {
    object {
        var type := "string"
        var value := s
    }
}
method octetstok(s) {
    object {
        var type := "octets"
        var value := s
    }
}
method lbracetok() {
    object {
        var type := "lbrace"
        var value := "{"
    }
}
method rbracetok() {
    object {
        var type := "rbrace"
        var value := "}"
    }
}
method lparentok() {
    object {
        var type := "lparen"
        var value := "("
    }
}
method rparentok() {
    object {
        var type := "rparen"
        var value := ")"
    }
}
method lsquaretok() {
    object {
        var type := "lsquare"
        var value := "["
    }
}
method rsquaretok() {
    object {
        var type := "rsquare"
        var value := "]"
    }
}
method commatok() {
    object {
        var type := "comma"
        var value := ","
    }
}
method dottok() {
    object {
        var type := "dot"
        var value := "."
    }
}
method numtok(v) {
    object {
        var type := "num"
        var value := v
    }
}
method keywordtok(v) {
    object {
        var type := "keyword"
        var value := v
    }
}
method optok(v) {
    object {
        var type := "op"
        var value := v
    }
}
method arrowtok() {
    object {
        var type := "arrow"
        var value := "->"
    }
}
method bindtok() {
    object {
        var type := "bind"
        var value := ":="
    }
}


method modechange(tokens, mode, accum) {
    var done := false
    var tok := 0
    if ((mode /= "n") | (length(accum) > 0)) then {
        if (mode == "i") then {
            tok := identifiertok(accum)
            if ((accum == "object") | (accum == "method")
                | (accum == "var") | (accum == "import")) then {
                tok := keywordtok(accum)
            }
            if (accum == "and") then {
                tok := optok("&")
            }
            tokens.push(tok)
            done := true
        }
        if (mode == "'") then {
            tok := stringtok(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == "\"") then {
            tok := stringtok(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == "x") then {
            tok := octetstok(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == ",") then {
            tok := commatok()
            tokens.push(tok)
            done := true
        }
        if (mode == ".") then {
            tok := dottok()
            tokens.push(tok)
            done := true
        }
        if (mode == "{") then {
            tok := lbracetok()
            tokens.push(tok)
            done := true
        }
        if (mode == "}") then {
            tok := rbracetok()
            tokens.push(tok)
            done := true
        }
        if (mode == "(") then {
            tok := lparentok()
            tokens.push(tok)
            done := true
        }
        if (mode == ")") then {
            tok := rparentok()
            tokens.push(tok)
            done := true
        }
        if (mode == "[") then {
            tok := lsquaretok()
            tokens.push(tok)
            done := true
        }
        if (mode == "]") then {
            tok := rsquaretok()
            tokens.push(tok)
            done := true
        }
        if (mode == "m") then {
            tok := numtok(accum)
            tokens.push(tok)
            done := true
        }
        if (mode == "o") then {
            tok := optok(accum)
            if (accum == "->") then {
                tok := arrowtok()
            }
            if (accum == ":=") then {
                tok := bindtok()
            }
            tokens.push(tok)
            done := true
        }
        if (mode == "n") then {
            done := true
        }
        if mode == "c" then {
            done := true
        }
        if (done) then {
            //print(mode, accum, tokens)
        } else {
            syntax_error("Lexing error: no handler for mode " ++ mode ++
                " with accum " ++ accum)
        }
    }
}
var input := infile.read()

var ichars := ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
            "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
var mchars := ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
var ochars := ["+", "-", "/", "*", "=", ":", "<", ">", "%", "&", "|"]

var tokens := []
var mode := "n"
var newmode := mode
var instr := false
var accum := ""
var escaped := false
var prev := ""
for input each { c ->
    var ct := ""
    if (instr) then {

    } else {
        if (mode /= "c") then {
            if (c == " ") then {
                newmode := "n"
            }
            if (c == "'") then {
                newmode := "'"
                instr := true
            }
            if (c == "\"") then {
                newmode := "\""
                instr := true
                if prev == "x" then {
                    newmode := "x"
                    mode := "n"
                }
            }
            ct := ichars.contains(c)
            if (ct) then {
                newmode := "i"
            }
            ct := mchars.contains(c)
            if (ct & (mode /= "i")) then {
                newmode := "m"
            }
            ct := ochars.contains(c)
            if (ct) then {
                newmode := "o"
            }
            if ((c == "(") | (c == ")") | (c == ",") | (c == ".")
                | (c == "{") | (c == "}") | (c == "[") | (c == "]")) then {
                newmode := c
            }
            if ((c == ".") & (accum == ".")) then {
                mode := "o"
                newmode := mode
            }
            if ((c == "/") & (accum == "/")) then {
                mode := "c"
                newmode := mode
            }
        }
    }
    if ((mode == "x") & (c == "\"") & (escaped.not)) then {
        newmode := "n"
        instr := false
    }
    if ((mode == "\"") & (c == "\"") & (escaped.not)) then {
        newmode := "n"
        instr := false
    }
    if ((mode == "'") & (c == "'") & (escaped.not)) then {
        newmode := "n"
        instr := false
    }
    if newmode /= mode then {
        modechange(tokens, mode, accum)
        mode := newmode
        if (instr) then {
            accum := ""
        } else {
            accum := c
        }
        if ((mode == "(") | (mode == ")") | (mode == "[")
            | (mode == "]")) then {
            modechange(tokens, mode, accum)
            mode := "n"
            newmode := "n"
            accum := ""
        }
    } else {
        if (instr) then {
            if c == "\n" then {
                syntax_error("Newlines not permitted in string literals")
            }
            if escaped then {
                if ((c == "l") | (c == "n")) then {
                    accum := accum ++ "\n"
                } else {
                    accum := accum ++ c
                }
                escaped := false
            } else {
                if c == "\\" then {
                    escaped := true
                } else {
                    accum := accum ++ c
                }
            }
        } else {
            if (c == "\n") then {
                modechange(tokens, mode, accum)
                mode := "n"
                newmode := "n"
                accum := ""
            } else {
                accum := accum ++ c
            }
        }
    }
    if (c == "\n") then {
        linenum := linenum + 1
        tokens.push(object {
            var type := "line"
            var value := linenum + 0
        })
    }
    prev := c
}
modechange(tokens, mode, accum)

var values := []
var sym := object {
    var sym := tokens[0]
}
method next() {
    if (tokens.length > 0) then {
        sym.sym := tokens.pop()
        if ((sym.sym.type == "line") & (tokens.length > 0)) then {
            var l := sym.sym.value
            if l /= linenum then {
                linenum := l
                next()
            }
        }
    } else {
        sym.sym := object { var type := "eof" }
    }
}

method astfor(over, variable, body) {
    object {
        var type := "for"
        var value := over
        var variable := variable
        var body := body
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "For(" ++ self.variable.value ++ ")\n"
            s := s ++ spc ++ self.value.pretty(depth+1)
            s := s ++ "\n"
            s := s ++ spc ++ "Each:"
            for self.body each { x ->
                s := s ++ "\n  "++ spc ++ x.pretty(depth+2)
            }
            s
        }
    }
}
method astwhile(cond, body) {
    object {
        var type := "while"
        var value := cond
        var body := body
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "While\n"
            s := s ++ spc ++ self.value.pretty(depth+1)
            s := s ++ "\n"
            s := s ++ spc ++ "Do:"
            for self.body each { x ->
                s := s ++ "\n  "++ spc ++ x.pretty(depth+2)
            }
            s
        }
    }
}
method astif(cond, thenblock, elseblock) {
    object {
        var type := "if"
        var value := cond
        var thenblock := thenblock
        var elseblock := elseblock
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "If\n"
            s := s ++ spc ++ self.value.pretty(depth+1)
            s := s ++ "\n"
            s := s ++ spc ++ "Then:"
            for self.thenblock each { ix ->
                s := s ++ "\n  "++ spc ++ ix.pretty(depth+2)
            }
            s := s ++ "\n"
            s := s ++ spc ++ "Else:"
            for self.elseblock each { ix ->
                s := s ++ "\n  "++ spc ++ ix.pretty(depth+2)
            }
            s
        }
    }
}
method astmethod(name, params, body) {
    object {
        var type := "method"
        var value := name
        var params := params
        var body := body
        var selfclosure := false
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "Method\n"
            s := s ++ spc ++ "Name: " ++ self.value.pretty(depth+1)
            s := s ++ "\n"
            s := s ++ spc ++ "Parameters:"
            for self.params each { mx ->
                s := s ++ "\n  "++ spc ++ mx.pretty(depth+2)
            }
            s := s ++ "\n"
            s := s ++ spc ++ "Body:"
            for self.body each { mx ->
                s := s ++ "\n  "++ spc ++ mx.pretty(depth+2)
            }
            s
        }
    }
}
method astcall(what, with) {
    object {
        var type := "call"
        var value := what
        var with := with
        var line := 0 + linenum
        var register := ""
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "Call\n"
            s := s ++ spc ++ "Method:\n"
            s := s ++ "  " ++ spc ++ self.value.pretty(depth+2)
            s := s ++ "\n"
            s := s ++ spc ++ "Parameters:"
            for self.with each { x ->
                s := s ++ "\n  "++ spc ++ x.pretty(depth+2)
            }
            s
        }
    }
}
method astobject(body) {
    object {
        var type := "object"
        var value := body
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "Object"
            for self.value each { x ->
                s := s ++ "\n"++ spc ++ x.pretty(depth+1)
            }
            s
        }
    }
}
method astarray(values) {
    object {
        var type := "array"
        var value := values
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { ai ->
                spc := spc ++ "  "
            }
            var s := "Array"
            for self.value each { ax ->
                s := s ++ "\n"++ spc ++ ax.pretty(depth+1)
            }
            s
        }
    }
}
method astmember(what, in) {
    object {
        var type := "member"
        var value := what
        var in := in
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "Member(" ++ self.value ++ ")\n"
            s := s ++ spc ++ self.in.pretty(depth+1)
        }
    }
}
method astidentifier(n) {
    object {
        var type := "identifier"
        var value := n
        var register := ""
        var line := linenum
        method pretty(depth) {
            "Identifier(" ++ self.value ++ ")"
        }
    }
}
method astoctets(n) {
    object {
        var type := "octets"
        var value := n
        var register := ""
        var line := linenum
        method pretty(depth) {
            "Octets(" ++ self.value ++ ")"
        }
    }
}
method aststring(n) {
    object {
        var type := "string"
        var value := n
        var register := ""
        var line := linenum
        method pretty(depth) {
            "String(" ++ self.value ++ ")"
        }
    }
}
method astnum(n) {
    object {
        var type := "num"
        var value := n
        var register := ""
        var line := linenum
        method pretty(depth) {
            "Num(" ++ self.value ++ ")"
        }
    }
}
method astop(op, l, r) {
    object {
        var type := "op"
        var value := op
        var left := l
        var right := r
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "Op(" ++ self.value ++ ")"
            s := s ++ "\n"
            s := s ++ spc ++ self.left.pretty(depth + 1)
            s := s ++ "\n"
            s := s ++ spc ++ self.right.pretty(depth + 1)
            s
        }
    }
}
method astindex(expr, index) {
    object {
        var type := "index"
        var value := expr
        var index := index
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "Index"
            s := s ++ "\n"
            s := s ++ spc ++ self.value.pretty(depth + 1)
            s := s ++ "\n"
            s := s ++ spc ++ self.index.pretty(depth + 1)
            s
        }
    }
}
method astbind(dest, val) {
    object {
        var type := "bind"
        var dest := dest
        var value := val
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "Bind"
            s := s ++ "\n"
            s := s ++ spc ++ self.dest.pretty(depth + 1)
            s := s ++ "\n"
            s := s ++ spc ++ self.value.pretty(depth + 1)
            s
        }
    }
}
method astvardec(name, val) {
    object {
        var type := "vardec"
        var name := name
        var value := val
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "VarDec"
            s := s ++ "\n"
            s := s ++ spc ++ self.name.pretty(depth + 1)
            if self.value then {
                s := s ++ "\n    "
                s := s ++ spc ++ self.value.pretty(depth + 1)
            }
            s
        }
    }
}
method astimport(name) {
    object {
        var type := "import"
        var value := name
        var register := ""
        var line := linenum
        method pretty(depth) {
            var spc := ""
            for 0..depth each { i ->
                spc := spc ++ "  "
            }
            var s := "Import"
            s := s ++ "\n"
            s := s ++ spc ++ self.name.pretty(depth + 1)
            s
        }
    }
}
method accept(t) {
    sym.sym.type == t
}
method pushnum() {
    var o := astnum(sym.sym.value)
    values.push(o)
    next()
}
method pushoctets() {
    var o := astoctets(sym.sym.value)
    values.push(o)
    next()
}
method pushstring() {
    var o := aststring(sym.sym.value)
    values.push(o)
    next()
}
method pushidentifier() {
    var o := astidentifier(sym.sym.value)
    values.push(o)
    next()
}
method doif() {
    if (accept("identifier") & (sym.sym.value == "if")) then {
        next()
        expression()
        var cond := values.pop()
        var body := []
        var elseblock := []
        var v
        if (accept("identifier") & (sym.sym.value == "then")) then {
            next()
            if accept("lbrace") then {
                next()
                while {(accept("rbrace")).not} do {
                    statement()
                    v := values.pop()
                    body.push(v)
                }
                next()
            }
            if (accept("identifier") & (sym.sym.value == "else")) then {
                next()
                if accept("lbrace") then {
                    next()
                    while {(accept("rbrace")).not} do {
                        statement()
                        v := values.pop()
                        elseblock.push(v)
                    }
                    next()
                }
            }
            var o := astif(cond, body, elseblock)
            values.push(o)
        }
    }
}
method dofor() {
    if (accept("identifier") & (sym.sym.value == "for")) then {
        next()
        var over
        expression()
        over := values.pop()
        var body := []
        var variable
        if (accept("identifier") & (sym.sym.value == "each")) then {
            next()
            if accept("lbrace") then {
                next()
                identifier()
                variable := values.pop()
                if accept("arrow") then {
                    next()
                    while {(accept("rbrace")).not} do {
                        statement()
                        var v := values.pop()
                        body.push(v)
                    }
                    next()
                }
            }
            var o := astfor(over, variable, body)
            values.push(o)
        }
    }
}
method dowhile() {
    if (accept("identifier") & (sym.sym.value == "while")) then {
        next()
        var cond
        if accept("lbrace") then {
            next()
            expression()
            cond := values.pop()
            if accept("rbrace") then {
                next()
            }
        }
        var body := []
        if (accept("identifier") & (sym.sym.value == "do")) then {
            next()
            if accept("lbrace") then {
                next()
                while {(accept("rbrace")).not} do {
                    statement()
                    var v := values.pop()
                    body.push(v)
                }
                next()
            }
            var o := astwhile(cond, body)
            values.push(o)
        }
    }
}
method identifier() {
    if accept("identifier") then {
        if sym.sym.value == "if" then {
            doif()
        } else {
            if sym.sym.value == "while" then {
                dowhile()
            } else {
                if sym.sym.value == "for" then {
                    dofor()
                } else {
                    pushidentifier()
                }
            }
        }
    }
}
method expression() {
    if accept("lparen") then {
        next()
        expression()
        if accept("rparen") then {
            next()
        }
    } else {
        if accept("num") then {
            pushnum()
        } else{
            if accept("string") then {
                pushstring()
            } else {
                if accept("octets") then {
                    pushoctets()
                } else {
                    if accept("identifier") then {
                        identifier()
                    } else {
                        if (accept("keyword") & (sym.sym.value == "object")) then {
                            doobject()
                        } else {
                            if accept("lsquare") then {
                                doarray()
                            }
                        }
                    }
                }
            }
        }
    }
    dotrest()
    postfixsquare()
    callrest()
    expressionrest()
//    if accept("dot") then {
//        dotrest()
//    } else {
//        if accept("lparen") then {
//            callrest()
//        }
//    }
//    if accept("op") then {
//        expressionrest()
//    }
}
method postfixsquare() {
    if accept("lsquare") then {
        next()
        var expr := values.pop()
        expression()
        var index := values.pop()
        if accept("rsquare") then {
            next()
            var o := astindex(expr, index)
            values.push(o)
        } else {
        }
    }
}
method expressionrest() {
    if accept("op") then {
        var a := values.pop()
        var ero := astop(sym.sym.value, a, 0)
        if sym.sym.value == "=" then {
            syntax_error("No such operator '='.")
        }
        next()
        expression()
        ero.right := values.pop()
        values.push(ero)
    }
}
method dotrest() {
    if accept("dot") then {
        var lookuptarget := values.pop()
        next()
        if accept("identifier") then {
            var dro := astmember(sym.sym.value, lookuptarget)
            values.push(dro)
            next()
            if accept("dot") then {
                dotrest()
            } else {
                if accept("lparen") then {
                    callrest()
                }
            }
        }
    }
}
method callrest() {
    if accept("lparen") then {
        var meth := values.pop()
        next()
        values.push(object {
            var type := "lparen"
            var register := ""
        })
        expression()
        while {accept("comma")} do {
            next()
            expression()
        }
        if accept("rparen") then {
            var tmpparams := []
            var n := values.pop()
            while {n.type /= "lparen"} do {
                tmpparams.push(n)
                n := values.pop()
            }
            var params := []
            for 0..tmpparams.length-1 each { x ->
                var p := tmpparams.pop()
                params.push(p)
            }
            var o := astcall(meth, params)
            values.push(o)
            next()
        }
    }
}
method vardec() {
    if (accept("keyword") & (sym.sym.value == "var")) then {
        next()
        pushidentifier()
        var val
        var name := values.pop()
        if accept("bind") then {
            next()
            expression()
            val := values.pop()
        }
        var o := astvardec(name, val)
        values.push(o)
    }
}
method doarray() {
    if accept("lsquare") then {
        next()
        values.push(object {
            var type := "lsquare"
            var register := ""
        })
        expression()
        while {accept("comma")} do {
            next()
            expression()
        }
        if accept("rsquare") then {
            var tmpparams := []
            var n := values.pop()
            while {n.type /= "lsquare"} do {
                tmpparams.push(n)
                n := values.pop()
            }
            var params := []
            for 0..tmpparams.length-1 each { x ->
                var p := tmpparams.pop()
                params.push(p)
            }
            var o := astarray(params)
            values.push(o)
            next()
        } else {
            syntax_error("expected rsquare, got " ++ sym.sym.type)
        }
    }
}
method doobject() {
    // doobject because "object" is a keyword
    if (accept("keyword") & (sym.sym.value == "object")) then {
        next()
        if accept("lbrace") then {
            values.push(object {
                var type := "lbrace"
                var register := ""
            })
            next()
            while {(accept("rbrace")).not} do {
                vardec()
                methoddec()
            }
            next()
            var rbody := []
            var n := values.pop()
            while {n.type /= "lbrace"} do {
                rbody.push(n)
                n := values.pop()
            }
            var body := []
            for 0..rbody.length-1 each { x ->
                var p := rbody.pop()
                body.push(p)
            }
            var o := astobject(body)
            values.push(o)
        }
    }
}
method methoddec() {
    if (accept("keyword") & (sym.sym.value == "method")) then {
        next()
        pushidentifier()
        var meth := values.pop()
        var rparams := []
        if accept("lparen") then {
            next()
            values.push(object {
                var type := "lparen"
                var register := ""
            })
            identifier()
            while {accept("comma")} do {
                next()
                identifier()
            }
            if accept("rparen") then {
                next()
                var tmpparams := []
                var n := values.pop()
                while {n.type /= "lparen"} do {
                    tmpparams.push(n)
                    n := values.pop()
                }
                var params := []
                for 0..tmpparams.length-1 each { x ->
                    var p := tmpparams.pop()
                    params.push(p)
                }
                var body := []
                if accept("lbrace") then {
                    next()
                    values.push(object {
                        var type := "lbrace"
                        var register := ""
                    })
                    statement()
                    var s := values.pop()
                    while {s.type /= "lbrace"} do {
                        body.push(s)
                        statement()
                        s := values.pop()
                    }
                    if accept("rbrace") then {
                        next()
                    } else {
                        syntax_error("No statement but not end of "
                            ++ meth.value ++ ". Have " ++ sym.sym.type ++ ".")
                    }
                } else {
                    syntax_error("No body in method declaration for " ++
                        meth.value)
                }
                var o := astmethod(meth, params, body)
                values.push(o)
            }
        }
    }
}
method doimport() {
    if accept('keyword') & (sym.sym.value == "import") then {
        next()
        identifier()
        var p := values.pop()
        var o := astimport(p)
        values.push(o)
    }
}
method statement() {
    if accept("keyword") then {
        if sym.sym.value == "var" then {
            vardec()
        } else {
            if sym.sym.value == "method" then {
                methoddec()
            } else {
                if sym.sym.value == "import" then {
                    doimport()
                } else {
                    expression()
                }
            }
        }
    } else {
        expression()
        if (accept("bind")) then {
            var dest := values.pop()
            next()
            expression()
            var val := values.pop()
            var o := astbind(dest, val)
            values.push(o)
        }
    }
}

var otoks := tokens
tokens := []
for 0..(otoks.length-1) each { i ->
    var o := otoks.pop()
    tokens.push(o)
}
linenum := 1
next()
var oldlength := tokens.length + 0
if tokens.length == 0 then {
    // Single token is ignored otherwise
    statement()
}
while {tokens.length > 0} do {
    statement()
    if tokens.length == oldlength then {
        var next := []
        for 0..5 each {i->
            if i < tokens.length then {
                next.push(tokens.at(i))
            }
        }
        syntax_error("No token consumed. Next tokens: " ++ next)
    }
    oldlength := tokens.length + 0
}
outprint(";-------------LLVM IR------------")
var auto_count := 0
var constants := []
var output := []
var usedvars := []
var declaredvars := []
var bblock := "entry"
method out(s) {
    output.push(s)
}
method beginblock(s) {
    bblock := "%" ++ s
    out(s ++ ":")
}
method compilearray(o) {
    var myc := auto_count
    auto_count := auto_count + 1
    var r
    out("  %array" ++ myc ++ " = call %object* @alloc_Array()")
    for o.value each {a ->
        r := compilenode(a)
        out("  store %object* " ++ r ++ ", %object** %params_0")
        out("  call %object* @callmethod(%object* %array"
            ++ myc ++ ", i8* getelementptr([5 x i8]* @.str._push"
            ++ ",i32 0,i32 0), i32 1, %object** %params)")
    }
    o.register := "%array" ++ myc
}
method compilemember(o) {
    // Member in value position is actually a nullary method call.
    var l := []
    var c := astcall(o, l)
    var r := compilenode(c)
    o.register := r
}
method compileobjvardec(o, selfr, pos) {
    var val := "%undefined"
    if o.value then {
        val := compilenode(o.value)
    }
    var myc := auto_count
    auto_count := auto_count + 1
    var nm := o.name.value
    var len := length(nm) + 1
    var con := "@.str.methname" ++ myc ++ " = private unnamed_addr "
        ++ "constant [" ++ len ++ " x i8] c\"" ++ nm ++ "\\00\""
    constants.push(con)
    out("; OBJECT VAR DEC " ++ nm)
    out("  call void @adddatum(%object* " ++ selfr
        ++ ", %object* " ++ val ++ ", i32 " ++ pos ++ ")")
    outprint("define %object* @reader_" ++ nm ++ "_" ++ myc
        ++ "(%object* %self, i32 %nparams, "
        ++ "%object** %args) {")
    outprint("  %dt = getelementptr %object* %self, i32 0, i32 2")
    outprint("  %tmp1 = load %object*** %dt")
    outprint("  %arrayidx = getelementptr %object** %tmp1, i32 " ++ pos)
    outprint("  %tmp2 = load %object** %arrayidx")
    outprint("  ret %object* %tmp2")
    outprint("}")
    out("  call void @addmethod(%object* " ++ selfr
        ++ ", i8* getelementptr(["
        ++ len ++ " x i8]* @.str.methname" ++ myc ++ ", i32 0, i32 0), "
        ++ "%object*(%object*, i32, %object**)* getelementptr(%object* " 
        ++ "(%object*, i32, %object**)* @reader_" ++ nm ++ "_" ++ myc ++ "))")
    var nmw := nm ++ ":="
    len := length(nmw) + 1
    con := "@.str.methnamew" ++ myc ++ " = private unnamed_addr "
        ++ "constant [" ++ len ++ " x i8] c\"" ++ nmw ++ "\\00\""
    constants.push(con)
    outprint("define %object* @writer_" ++ nm ++ "_" ++ myc
        ++ "(%object* %self, i32 %nparams, "
        ++ "%object** %args) {")
    outprint("  %params = getelementptr %object** %args, i32 0")
    outprint("  %par0 = load %object** %params")
    outprint("  %dt = getelementptr %object* %self, i32 0, i32 2")
    outprint("  %tmp1 = load %object*** %dt")
    outprint("  %arrayidx = getelementptr %object** %tmp1, i32 " ++ pos)
    outprint("  store %object* %par0, %object** %arrayidx")
    outprint("  ret %object* %par0")
    outprint("}")
    out("  call void @addmethod(%object* " ++ selfr
        ++ ", i8* getelementptr(["
        ++ len ++ " x i8]* @.str.methnamew" ++ myc ++ ", i32 0, i32 0), "
        ++ "%object*(%object*, i32, %object**)* getelementptr(%object* " 
        ++ "(%object*, i32, %object**)* @writer_" ++ nm ++ "_" ++ myc ++ "))")
}
method compileobject(o) {
    var myc := auto_count
    auto_count := auto_count + 1
    var selfr := "%obj" ++ myc
    out("  " ++ selfr ++ " = call %object* @alloc_obj()")
    var pos := 0
    for o.value each { e ->
        if e.type == "method" then {
            compilemethod(e, selfr)
        }
        if e.type == "vardec" then {
            compileobjvardec(e, selfr, pos)
            pos := pos + 1
        }
    }
    o.register := selfr
}
method compilefor(o) {
    var myc := auto_count
    auto_count := auto_count + 1
    var over := compilenode(o.value)
    var applymeth := astmethod(astidentifier("apply"),
        [o.variable], o.body)
    applymeth.selfclosure := true
    var objbody := astobject([applymeth])
    var obj := compilenode(objbody)
    out("  store %object* " ++ over ++ ", %object** %params_0")
    out("  %iter" ++ myc ++ " = call %object* @callmethod(%object* " ++ over
        ++ ", i8* getelementptr([5 x i8]* @.str._iter"
        ++ ",i32 0,i32 0), i32 1, %object** %params)")
    
    out("  br label %BeginFor" ++ myc)
    beginblock("BeginFor" ++ myc)
    out("  %condobj" ++ myc ++ " = call %object* @callmethod(%object* %iter"
        ++ myc
        ++ ", i8* getelementptr([9 x i8]* @.str._havemore"
        ++ ",i32 0,i32 0), i32 1, %object** %params)")
    var creg := "%cond" ++ myc
    out("  " ++ creg ++ "_valp = call i1 @istrue(%object* %condobj"
        ++ myc ++ ")")
    out("  " ++ creg ++ " = icmp eq i1 0, " ++ creg ++ "_valp")
    out("br i1 " ++ creg ++ ", label %EndFor" ++ myc
        ++ ", label %ForBody" ++ myc)
    beginblock("ForBody" ++ myc)
    var tret := "null"
    var tblock := "ERROR"
    out(" %forval" ++ myc ++ " = call %object* @callmethod(%object* %iter"
        ++ myc
        ++ ", i8* getelementptr([5 x i8]* @.str._next"
        ++ ",i32 0,i32 0), i32 0, %object** %params)")
    out("  store %object* %forval" ++ myc ++ ", %object** %params_0")
    out("  call %object* @callmethod(%object* " ++ obj
        ++ ", i8* getelementptr([6 x i8]* @.str._apply"
        ++ ",i32 0,i32 0), i32 1, %object** %params)")
    tblock := bblock
    out("  br label %BeginFor" ++ myc)
    beginblock("EndFor" ++ myc)
    o.register := over // "%while" ++ myc
}
method compilemethod(o, selfobj) {
    // How to deal with closures:
    // Calculate body, find difference of usedvars/declaredvars, if closure
    // then build as such. At top of method body bind %var_x as usual, but
    // set to pointer from the additional closure parameter.
    var oldout := output
    var oldbblock := bblock
    var oldusedvars := usedvars
    var olddeclaredvars := declaredvars
    output := []
    usedvars := []
    declaredvars := []
    var myc := auto_count
    auto_count := auto_count + 1
    var name := o.value.value
    var nm := name ++ myc
    beginblock("entry")
    output.pop()
    out("  %ptrsize_p = getelementptr %object** null, i32 1")
    out("  %ptrsize = ptrtoint %object** %ptrsize_p to i32")
    out("  %paramssize = mul i32 %ptrsize, 16")
    out("  %paramsu = call i8* @malloc(i32 %paramssize)")
    out("  %params = bitcast i8* %paramsu to %object**")
    for 0..10 each { i ->
        out("  %params_" ++ i ++ " = getelementptr %object** %params, i32 "
            ++ i)
    }
    var i := 0
    for o.params each { p ->
        out("  %var_" ++ p.value ++ " = getelementptr %object** %args, "
            ++ "i32 " ++ i)
        var pn := p.value
        declaredvars.push(pn)
        i := i + 1
    }
    out("  %undefined = load %object** @undefined")
    var ret := "%undefined"
    for o.body each { l ->
        ret := compilenode(l)
    }
    out("  ret %object* " ++ ret)
    out("}")
    var body := output
    output := []
    var closurevars := []
    for usedvars each { u ->
        var decl := false
        for declaredvars each { d->
            if d == u then {
                decl := true
            }
        }
        if decl then {
            decl := decl
        } else {
            var found := false
            for closurevars each { v ->
                if v == u then {
                    found := true
                }
            }
            if found then {
                found := found
            } else {
                closurevars.push(u)
            }
        }
    }
    if o.selfclosure then {
        closurevars.push("self")
    }
    outprint(";;;; METHOD DEFINITION: " ++ name)
    if closurevars.length > 0 then {
        out("; have closure method: " ++ closurevars.length)
        if o.selfclosure then {
            out("define %object* @meth_" ++ nm ++ "(%object* %realself, i32 %nparams, "
                ++ "%object** %args, %object*** %closure) {")
        } else {
            out("define %object* @meth_" ++ nm ++ "(%object* %self, i32 %nparams, "
                ++ "%object** %args, %object*** %closure) {")
        }
    } else {
        out("define %object* @meth_" ++ nm ++ "(%object* %self, i32 %nparams, "
            ++ "%object** %args) {")
    }
    beginblock("entry")
    var j := 0
    for closurevars each { cv ->
        if cv == "self" then {
            out("  %varc_" ++ cv ++ " = getelementptr %object*** %closure, i32 " ++ j)
            out("  %self2 = load %object*** %varc_" ++ cv)
            out("  %self = load %object** %self2")
        } else {
            out("  %varc_" ++ cv ++ " = getelementptr %object*** %closure, i32 " ++ j)
            out("  %var_" ++ cv ++ " = load %object*** %varc_" ++ cv)
        }
        j := j + 1
    }
    for body each { l->
        out(l)
    }
    out(";;;; ENDS")
    for output each {l ->
        outprint(l)
    }
    output := oldout
    bblock := oldbblock
    usedvars := oldusedvars
    declaredvars := olddeclaredvars
    var len := length(name) + 1
    var con := "@.str.methname" ++ myc ++ " = private unnamed_addr "
        ++ "constant [" ++ len ++ " x i8] c\"" ++ name ++ "\\00\""
    constants.push(con)
    if closurevars.length == 0 then {
        out("  call void @addmethod(%object* " ++ selfobj
            ++ ", i8* getelementptr(["
            ++ len ++ " x i8]* @.str.methname" ++ myc ++ ", i32 0, i32 0), "
            ++ "%object*(%object*, i32, %object**)* getelementptr(%object* " 
            ++ "(%object*, i32, %object**)* @meth_" ++ nm ++ "))")
    } else {
        out("  %closure" ++ myc ++ " = call %object*** @createclosure(i32 "
            ++ closurevars.length ++ ")")
        for closurevars each { v ->
            if v == "self" then {
                out("  %selfpp" ++ auto_count ++ " = "
                    ++ "call %object** @alloc_var()")
                out("  store %object* %self, %object** %selfpp" ++ auto_count)
                out("  call void @addtoclosure(%object*** %closure" ++ myc ++ ", "
                    ++ "%object** %selfpp" ++ auto_count ++ ")")
                auto_count := auto_count + 1
            } else {
                out("  call void @addtoclosure(%object*** %closure" ++ myc ++ ", "
                    ++ "%object** %var_" ++ v ++ ")")
            }
        }
        out("  call void @addclosuremethod(%object* " ++ selfobj
            ++ ", i8* getelementptr(["
            ++ len ++ " x i8]* @.str.methname" ++ myc ++ ", i32 0, i32 0), "
            ++ "%object*(%object*, i32, %object**, %object***)* getelementptr(%object* " 
            ++ "(%object*, i32, %object**, %object***)* @meth_" ++ nm
            ++ "), %object*** %closure" ++ myc ++ ")")
    }
}
method compilewhile(o) {
    var myc := auto_count
    auto_count := auto_count + 1
    out("  br label %BeginWhile" ++ myc)
    beginblock("BeginWhile" ++ myc)
    var cond := compilenode(o.value)
    var creg := "%cond" ++ myc
    out("  " ++ creg ++ "_valp = call i1 @istrue(%object* "
        ++ cond ++ ")")
    out("  " ++ creg ++ " = icmp eq i1 0, " ++ creg ++ "_valp")
    out("br i1 " ++ creg ++ ", label %EndWhile" ++ myc
        ++ ", label %WhileBody" ++ myc)
    beginblock("WhileBody" ++ myc)
    var tret := "null"
    var tblock := "ERROR"
    for o.body each { l->
        tret := compilenode(l)
    }
    tblock := bblock
    out("  br label %BeginWhile" ++ myc)
    beginblock("EndWhile" ++ myc)
    //out("  %while" ++ myc ++ " = phi %object* [ " ++ tret ++ ", "
    //    ++ tblock ++ "], [" ++ cond ++ ", %BeginIf" ++ myc ++ "]")
    o.register := cond // "%while" ++ myc
}
method compileif(o) {
    var myc := auto_count
    auto_count := auto_count + 1
    out("  br label %BeginIf" ++ myc)
    beginblock("BeginIf" ++ myc)
    var cond := compilenode(o.value)
    var creg := "%cond" ++ myc
    out("  " ++ creg ++ "_valp = call i1 @istrue(%object* "
        ++ cond ++ ")")
    out("  " ++ creg ++ " = icmp eq i1 0, " ++ creg ++ "_valp")
    var startblock := bblock
    if o.elseblock.length > 0 then {
        out("br i1 " ++ creg ++ ", label %FalseBranch" ++ myc
            ++ ", label %TrueBranch" ++ myc)
    } else {
        out("  %undefined" ++ myc ++ " = load %object** @undefined")
        out("br i1 " ++ creg ++ ", label %EndIf" ++ myc
            ++ ", label %TrueBranch" ++ myc)
    }
    beginblock("TrueBranch" ++ myc)
    var tret := "%undefined"
    var fret := "%undefined"
    var tblock := "ERROR"
    var fblock := "ERROR"
    for o.thenblock each { l->
        tret := compilenode(l)
    }
    tblock := bblock
    out("  br label %EndIf" ++ myc)
    if o.elseblock.length > 0 then {
        beginblock("FalseBranch" ++ myc)
        for o.elseblock each { l->
            fret := compilenode(l)
        }
        out("  br label %EndIf" ++ myc)
        fblock := bblock
    }
    beginblock("EndIf" ++ myc)
    if o.elseblock.length > 0 then {
        out("  %if" ++ myc ++ " = phi %object* [ " ++ tret ++ ", "
            ++ tblock ++ "], [" ++ fret ++ ", " ++ fblock ++ "]")
    } else {
        out("  %if" ++ myc ++ " = phi %object* [ " ++ tret ++ ", "
            ++ tblock ++ "], [%undefined" ++ myc ++ ", " ++ startblock ++ "]")
    }
    o.register := "%if" ++ myc
}
method compileidentifier(o) {
    var name := o.value
    if name == "self" then {
        o.register := "%self"
    } else {
        if modules.contains(name) then {
            out("  %var_val_" ++ name ++ auto_count ++
                " = load %object** @.module." ++ name)
        } else {
            usedvars.push(name)
            out("  %var_val_" ++ name ++ auto_count ++ " = load %object** "
                ++ "%var_" ++ name)
        }
        o.register := "%var_val_" ++ name ++ auto_count
        auto_count := auto_count + 1
    }
}
method compilebind(o) {
    var dest := o.dest
    var val := ""
    var c := ""
    var r := ""
    if dest.type == "identifier" then {
        val := o.value
        val := compilenode(val)
        var nm := dest.value
        usedvars.push(nm)
        out("  store %object* " ++ val ++ ", %object** %var_" ++ nm)
        o.register := val
    } else {
        if dest.type == "member" then {
            out("; WARNING: non-local assigns not yet fully supported")
            dest.value := dest.value ++ ":="
            c := astcall(dest, [o.value])
            r := compilenode(c)
            o.register := r
        }
        if dest.type == "index" then {
            var imem := astmember("[]:=", dest.value)
            c := astcall(imem, [dest.index, o.value])
            r := compilenode(c)
            o.register := r
        }
    }
}
method compilevardec(o) {
    var nm := o.name.value
    declaredvars.push(nm)
    var val := o.value
    if val then {
        val := compilenode(val)
    } else {
        val := "%undefined"
    }
    //scopes[scopes.length-1].push([nm, val])
    out("  %var_" ++ nm ++ " = call %object** @alloc_var()")
    out("  store %object* " ++ val ++ ", %object** %var_"
        ++ nm)
    o.register := val
}
method compileindex(o) {
    var of := compilenode(o.value)
    var index := compilenode(o.index)
    out("  store %object* " ++ index ++ ", %object** %params_0")
    out("  %idxres" ++ auto_count ++ " = call %object* @callmethod(%object* "
        ++ of ++ ", i8* getelementptr([3 x i8]* @.str._index"
        ++ ",i32 0,i32 0), i32 1, %object** %params)")
    o.register := "%idxres" ++ auto_count
    auto_count := auto_count + 1
}
method compileop(o) {
    var left := compilenode(o.left)
    var right := compilenode(o.right)
    // Sometimes they don"t? Or something.
    auto_count := auto_count + 1
    if ((o.value == "+") | (o.value == "*") | (o.value == "/") |
        (o.value == "-") | (o.value == "%")) then {
        var rnm := "sum"
        var opnm := "plus"
        if (o.value == "*") then {
            rnm := "prod"
            opnm := "asterisk"
        }
        if (o.value == "/") then {
            rnm := "quotient"
            opnm := "slash"
        }
        if (o.value == "-") then {
            rnm := "diff"
            opnm := "minus"
        }
        if (o.value == "%") then {
            rnm := "modulus"
            opnm := "percent"
        }
        out("  store %object* " ++ right ++ ", %object** %params_0")
        out("  %" ++ rnm ++ auto_count ++ " = call %object* @callmethod(%object* "
            ++ left ++ ", i8* getelementptr([2 x i8]* @.str._" ++ opnm
            ++ ",i32 0,i32 0), i32 1, %object** %params)")
        o.register := "%" ++ rnm ++ auto_count
        auto_count := auto_count + 1
    } else {
        var len := length(o.value) + 1
        var con := "@.str" ++ constants.length ++ " = private unnamed_addr "
            ++ "constant [" ++ len ++ " x i8] c\"" ++ o.value ++ "\\00\""
        out("  store %object* " ++ right ++ ", %object** %params_0")
        out("  %opresult" ++ auto_count ++ " = call %object* "
            ++ "@callmethod(%object* " ++ left
            ++ ", i8* getelementptr([" ++ len ++ " x i8]* @.str"
            ++ constants.length ++ ",i32 0,i32 0), i32 1, %object** %params)")
        constants.push(con)
        o.register := "%opresult" ++ auto_count
        auto_count := auto_count + 1
    }
}
method compilecall(o) {
    var args := []
    var obj := ""
    var len := 0
    var con := ""
    for o.with each { p ->
        var r := compilenode(p)
        args.push(r)
    }
    for 0..(args.length-1) each { i ->
        out("  store %object* " ++ args[i] ++ ", %object** %params_" ++ i)
    }
    if (o.value.type == "member") then {
        outprint("; handling member")
        obj := compilenode(o.value.in)
        outprint("; compiled in to " ++ obj)
        len := length(o.value.value) + 1
        outprint("; got len " ++ len)
        con := "@.str" ++ constants.length ++ " = private unnamed_addr "
            ++ "constant [" ++ len ++ " x i8] c\"" ++ o.value.value ++ "\\00\""
        outprint("; created con")
        out("  %call" ++ auto_count ++ " = call %object* "
            ++ "@callmethod(%object* " ++ obj
            ++ ", i8* getelementptr([" ++ len ++ " x i8]* @.str"
            ++ constants.length ++ ",i32 0,i32 0), i32 "
            ++ args.length ++ ", %object** %params)")
        outprint("; pushed statement")
        constants.push(con)
    } else {
        out("; WARNING: non-member calls not fully supported yet")
        obj := "%self"
        len := length(o.value.value) + 1
        con := "@.str" ++ constants.length ++ " = private unnamed_addr "
            ++ "constant [" ++ len ++ " x i8] c\"" ++ o.value.value ++ "\\00\""
        out("  %call" ++ auto_count ++ " = call %object* "
            ++ "@callmethod(%object* " ++ obj
            ++ ", i8* getelementptr([" ++ len ++ " x i8]* @.str"
            ++ constants.length ++ ",i32 0,i32 0), i32 "
            ++ args.length ++ ", %object** %params)")
        constants.push(con)
    }
    o.register := "%call" ++ auto_count
    out("; compilecall giving return register " ++ o.register)
    auto_count := auto_count + 1
}
method hexdecchar(c) {
    var chars := ["0", "1", "2", "3", "4", "5", "6", "7", "8",
                 "9", "a", "b", "c", "d", "e", "f"]
    var ret := 0
    for 0..15 each {i->
        if chars.at(i) == c then {
            ret := i
        }
    }
    ret
}
method compileoctets(o) {
    var escval := ""
    var l := length(o.value) / 2
    var i := 0
    for o.value each {c->
        if (i % 2) == 0 then {
            escval := escval ++ "\\"
        }
        escval := escval ++ c
        i := i + 1
    }
    out("  %tmp" ++ auto_count ++ " = load %object** @.octlit"
        ++ auto_count)
    out("  %cmp" ++ auto_count ++ " = icmp ne %object* %tmp"
        ++ auto_count ++ ", null")
    out("  br i1 %cmp" ++ auto_count ++ ", label %octlit"
        ++ auto_count ++ ".already, label %octlit"
        ++ auto_count ++ ".define")
    beginblock("octlit" ++ auto_count ++ ".already")
    out("  %alreadyoctets" ++ auto_count ++ " = load %object** @.octlit"
        ++ auto_count)
    out("  br label %octlit" ++ auto_count ++ ".end")
    beginblock("octlit" ++ auto_count ++ ".define")
    out("  %oct" ++ auto_count ++ " = getelementptr [" ++ l ++ " x i8]* @.oct" ++ constants.length ++ ", i32 0, i32 0")
    out("  %defoctets" ++ auto_count ++ " = call %object* "
        ++ "@alloc_Octets(i8* "
          ++ "%oct" ++ auto_count ++ ", i32 " ++ l ++ ")")
    out("  store %object* %defoctets" ++ auto_count ++ ", %object** "
        ++ "@.octlit" ++ auto_count)
    out("br label %octlit" ++ auto_count ++ ".end")
    beginblock("octlit" ++ auto_count ++ ".end")
    out(" %octets" ++ auto_count ++ " = phi %object* [%alreadyoctets"
        ++ auto_count ++ ", %octlit" ++ auto_count ++ ".already], "
        ++ "[%defoctets" ++ auto_count ++ ", %octlit" ++ auto_count
        ++ ".define]")
    var con := "@.oct" ++ constants.length ++ " = private unnamed_addr "
        ++ "constant [" ++ l ++ " x i8] c\"" ++ escval ++ "\""
    constants.push(con)
    con := ("@.octlit" ++ auto_count
        ++ " = private global %object* null")
    constants.push(con)
    o.register := "%octets" ++ auto_count
    auto_count := auto_count + 1
}
method compileimport(o) {
    out("; Import of " ++ o.value.value)
    var nm := o.value.value
    out("  %tmp_mod_" ++ nm ++ " = call %object* @module_"
        ++ nm ++ "_init()")
    out("  store %object* %tmp_mod_" ++ nm ++ ", %object** @.module." ++ nm)
    out("  %var_" ++ nm ++ " = call %object** @alloc_var()")
    out("  store %object* %tmp_mod_" ++ nm ++ ", %object** %var_" ++ nm)
    var con := "@.module." ++ nm ++ " = private global %object* null"
    modules.push(nm)
    constants.push(con)
    con := "declare %object* @module_" ++ nm ++ "_init()"
    constants.push(con)
    o.register := "%undefined"
}
method compilenode(o) {
    if linenum /= o.line then {
        linenum := o.line
        out("; Begin line " ++ linenum)
        out("  call void @setline(i32 " ++ linenum ++ ")")
    }
    if (o.type == "num") then {
        out("  %num" ++ auto_count ++ " = call %object* @alloc_Float64(double "
            ++ o.value ++ ".0)")
        o.register := "%num" ++ auto_count
        auto_count := auto_count + 1
    }
    var l := ""
    if (o.type == "string") then {
        l := length(o.value)
        l := l + 1
        o.value := escapestring(o.value)
        out("  %tmp" ++ auto_count ++ " = load %object** @.strlit"
            ++ auto_count)
        out("  %cmp" ++ auto_count ++ " = icmp ne %object* %tmp"
            ++ auto_count ++ ", null")
        out("  br i1 %cmp" ++ auto_count ++ ", label %strlit"
            ++ auto_count ++ ".already, label %strlit"
            ++ auto_count ++ ".define")
        beginblock("strlit" ++ auto_count ++ ".already")
        out("  %alreadystring" ++ auto_count ++ " = load %object** @.strlit"
            ++ auto_count)
        out("  br label %strlit" ++ auto_count ++ ".end")
        beginblock("strlit" ++ auto_count ++ ".define")
        out("  %str" ++ auto_count ++ " = getelementptr [" ++ l ++ " x i8]* @.str" ++ constants.length ++ ", i32 0, i32 0")
        out("  %defstring" ++ auto_count ++ " = call %object* "
            ++ "@alloc_String(i8* "
              ++ "%str" ++ auto_count ++ ")")
        out("  store %object* %defstring" ++ auto_count ++ ", %object** "
            ++ "@.strlit" ++ auto_count)
        out("br label %strlit" ++ auto_count ++ ".end")
        beginblock("strlit" ++ auto_count ++ ".end")
        out(" %string" ++ auto_count ++ " = phi %object* [%alreadystring"
            ++ auto_count ++ ", %strlit" ++ auto_count ++ ".already], "
            ++ "[%defstring" ++ auto_count ++ ", %strlit" ++ auto_count
            ++ ".define]")
        var con := "@.str" ++ constants.length ++ " = private unnamed_addr "
            ++ "constant [" ++ l ++ " x i8] c\"" ++ o.value ++ "\\00\""
        constants.push(con)
        con := ("@.strlit" ++ auto_count
            ++ " = private global %object* null")
        constants.push(con)
        o.register := "%string" ++ auto_count
        auto_count := auto_count + 1
    }
    if (o.type == "index") then {
        compileindex(o)
    }
    if (o.type == "octets") then {
        compileoctets(o)
    }
    if (o.type == "import") then {
        compileimport(o)
    }
    if ((o.type == "identifier")
        & ((o.value == "true") | (o.value == "false"))) then {
        var val := 0
        if (o.value == "true") then {
            val := 1
        }
        out("  %bool" ++ auto_count ++ " = call %object* "
              ++ "@alloc_Boolean(i32 " ++ val ++ ")")
        o.register := "%bool" ++ auto_count
        auto_count := auto_count + 1
    } else {
        if (o.type == "identifier") then {
            compileidentifier(o)
        }
    }
    if (o.type == "vardec") then {
        compilevardec(o)
    }
    if (o.type == "method") then {
        compilemethod(o, "%self")
    }
    if (o.type == "array") then {
        compilearray(o)
    }
    if (o.type == "bind") then {
        compilebind(o)
    }
    if (o.type == "while") then {
        compilewhile(o)
    }
    if (o.type == "if") then {
        compileif(o)
    }
    if (o.type == "object") then {
        compileobject(o)
    }
    if (o.type == "member") then {
        compilemember(o)
    }
    if (o.type == "for") then {
        compilefor(o)
    }
    if ((o.type == "call")) then {
        if (o.value.value == "print") then {
            var args := []
            for o.with each { prm ->
                var r := compilenode(prm)
                args.push(r)
            }
            for 0..(args.length-1) each { i ->
                out("  store %object* " ++ args[i] ++ ", %object** %params_" ++ i)
            }
            out("  %call" ++ auto_count ++ " = call %object* @gracelib_print(%object* null, i32 "
                  ++ args.length ++ ", %object** %params)")
            o.register := "%call" ++ auto_count
            auto_count := auto_count + 1
        } else {
            if ((o.value.type == "identifier")
                & (o.value.value == "length")) then {
                if o.with.length == 0 then {
                    out("; PP FOLLOWS")
                    out(o.pretty(0))
                    tmp := "null"
                } else {
                    tmp := compilenode(o.with[0])
                }
                out("  %call" ++ auto_count ++ " = call %object* "
                    ++ "@gracelib_length(%object* " ++ tmp ++ ")")
                o.register := "%call" ++ auto_count
                auto_count := auto_count + 1
            } else {
                if ((o.value.type == "identifier")
                    & (o.value.value == "escapestring")) then {
                    tmp := o.with[0]
                    tmp := astmember("_escape", tmp)
                    tmp := astcall(tmp, [])
                    o.register := compilenode(tmp)
                } else {
                    compilecall(o)
                }
            }
        }
    }
    if (o.type == "op") then {
        compileop(o)
    }
    out("; compilenode returning " ++ o.register)
    o.register
}
out("@.str = private unnamed_addr constant [6 x i8] c\"Hello\\00\"")
out("@.str._plus = private unnamed_addr constant [2 x i8] c\"+\\00\"")
out("@.str._minus = private unnamed_addr constant [2 x i8] c\"-\\00\"")
out("@.str._asterisk = private unnamed_addr constant [2 x i8] c\"*\\00\"")
out("@.str._slash = private unnamed_addr constant [2 x i8] c\"/\\00\"")
out("@.str._percent = private unnamed_addr constant [2 x i8] c\"%\\00\"")
out("@.str._index = private unnamed_addr constant [3 x i8] c\"[]\\00\"")
out("@.str._push = private unnamed_addr constant [5 x i8] c\"push\\00\"")
out("@.str._iter = private unnamed_addr constant [5 x i8] c\"iter\\00\"")
out("@.str._apply = private unnamed_addr constant [6 x i8] c\"apply\\00\"")
out("@.str._havemore = private unnamed_addr constant [9 x i8] c\"havemore\\00\"")
out("@.str._next = private unnamed_addr constant [5 x i8] c\"next\\00\"")
out("@.str.asString = private unnamed_addr constant [9 x i8] c\"asString\\00\"")
out("@undefined = private global %object* null")
outprint("%method = type { i8*, %object*(%object *, i32, %object**)*,")
outprint("    %object***, %object*(%object *, i32, %object**,")
outprint("        %object***)*}")
outprint("%object = type { [32 x i8], %method**, %object**, i8**, i32, i32 }")
out("define i32 @main(i32 %argc, i8** %argv) {")
out("entry:")
out("  %ptrsize_p = getelementptr %object** null, i32 1")
out("  %ptrsize = ptrtoint %object** %ptrsize_p to i32")
out("  %paramssize = mul i32 %ptrsize, 16")
out("  %paramsu = call i8* @malloc(i32 %paramssize)")
out("  %params = bitcast i8* %paramsu to %object**")
for 0..10 each { i ->
    out("  %params_" ++ i ++ " = getelementptr %object** %params, i32 " ++ i)
}
out("  %self = call %object* @alloc_obj()")
out("  %undefined = call %object* @alloc_Undefined()")
out("  store %object* %undefined, %object** @undefined")
out("  %tmp_argv = call %object* @alloc_Array()")
out("  %argv_i = alloca i32")
out("  store i32 0, i32* %argv_i")
out("  br label %argv.cond")
beginblock("argv.cond")
out("  %argv_tmp1 = load i32* %argv_i, align 4")
out("  %argv_cmp = icmp slt i32 %argv_tmp1, %argc")
out("  br i1 %argv_cmp, label %argv.body, label %argv.end")
beginblock("argv.body")
out("  %argv_iv = load i32* %argv_i")
out("  %argv_idx = getelementptr i8** %argv, i32 %argv_iv")
out("  %argv_val = load i8** %argv_idx")
out("  %argv_tmp3 = call %object* @alloc_String(i8* %argv_val)")
out("  store %object* %argv_tmp3, %object** %params_0")
out("  call %object* @callmethod(%object* %tmp_argv, "
    ++ "i8* getelementptr([5 x i8]* @.str._push"
    ++ ",i32 0,i32 0), "
    ++ "i32 0, %object** %params)")
out("  %argv_inc = add i32 %argv_iv, 1")
out("  store i32 %argv_inc, i32* %argv_i")
out("  br label %argv.cond")
beginblock("argv.end")
out("  %var_argv = call %object** @alloc_var()")
out("  store %object* %tmp_argv, %object** %var_argv")
for values each { o ->
    compilenode(o)
}
out("  call void @gracelib_stats()")
out("  ret i32 0")
out("}")
out("define i32 @out(i8* %s) {")
out("entry:")
out("  call i32 @puts(i8* %s)")
out("  ret i32 0")
out("}")
out("; constant definitions")
for constants each { c ->
    out(c)
}
out("; gracelib")
out("declare %object* @alloc_obj()")
out("declare %object* @alloc_Array()")
out("declare %object* @alloc_Float64(double)")
out("declare %object* @alloc_String(i8*)")
out("declare %object* @alloc_Octets(i8*, i32)")
out("declare %object* @alloc_Boolean(i32)")
out("declare %object* @alloc_Undefined()")
out("declare %object* @callmethod(%object*, i8*, i32, %object**)")
out("declare void @addmethod(%object*, i8*, %object*(%object *, i32, %object**)*)")
out("declare %object* @gracelib_print(%object*, i32, %object**)")
out("declare %object* @gracelib_readall(%object*, i32, %object**)")
out("declare %object* @gracelib_length(%object*)")
out("declare %object** @alloc_var()")
out("declare i1 @istrue(%object*)")
out("declare void @gracelib_stats()")
out("declare %object*** @createclosure(i32)")
out("declare void @addtoclosure(%object***, %object**)")
out("declare void @addclosuremethod(%object*, i8*, %object*(%object*,")
out("    i32, %object**, %object***)*, %object***)")
out("declare void @adddatum(%object*, %object*, i32)")
out("declare void @setline(i32)")
out("; libc functions")
out("declare i32 @puts(i8*)")
out("declare i8* @malloc(i32)")
for output each { x ->
    outprint(x)
}
// To do:
// - Blocks
// - GC
// - Efficient strings
// - Tuples
// - Classes
// - Types
// - REPL
// - String escapes
// - return
// - Operator associativity
// - import
// - Numeric literals
